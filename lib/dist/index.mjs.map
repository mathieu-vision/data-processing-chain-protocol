{"version":3,"sources":["../src/utils/Logger.ts","../src/types/types.ts","../src/core/Node.ts","../src/agents/Agent.ts","../src/agents/ReportingAgent.ts","../src/agents/MonitoringAgent.ts","../src/core/NodeStatusManager.ts","../src/core/PipelineProcessor.ts","../src/core/NodeSupervisor.ts","../src/core/NodeSupervisorLogger.ts","../src/extensions/DefaultMonitoringSignalHandler.ts","../src/utils/http.ts","../src/extensions/DefaultReportingCallbacks.ts","../src/extensions/DefaultResolverCallbacks.ts","../src/extensions/DefaultNodeStatusBroadcaster.ts","../src/index.ts"],"sourcesContent":["import { WriteStream, createWriteStream, mkdirSync } from 'fs';\r\nimport { join } from 'path';\r\nimport { format } from 'util';\r\n\r\n/**\r\n * Represents the log levels for the Logger.\r\n * @typedef {'info' | 'warn' | 'error' | 'header'} LogLevel\r\n */\r\ntype LogLevel =\r\n  | 'event'\r\n  | 'info'\r\n  | 'warn'\r\n  | 'error'\r\n  | 'header'\r\n  | 'debug'\r\n  | 'event'\r\n  | 'special';\r\n\r\n/**\r\n * Configuration options for the Logger.\r\n * @interface LoggerConfig\r\n * @property {boolean} [preserveLogs] - If true, logs will be preserved and passed to an external callback.\r\n * @property {function(LogLevel, string, string): void} [externalCallback] - A callback function to handle preserved logs.\r\n */\r\ninterface LoggerConfig {\r\n  preserveLogs?: boolean;\r\n  externalCallback?: (\r\n    _level: LogLevel,\r\n    _message: string,\r\n    _timestamp: string,\r\n  ) => void;\r\n}\r\n\r\n// ANSI color codes for console output\r\nconst Colors = {\r\n  reset: '\\x1b[0m',\r\n  info: '\\x1b[32m', // green\r\n  warn: '\\x1b[93m', // yellow\r\n  error: '\\x1b[31m', // red\r\n  header: '\\x1b[36m', // cyan\r\n  debug: '\\x1b[90m', // gray\r\n  event: '\\x1b[35m', // magenta\r\n  special: '\\x1b[37m', // white\r\n} as const;\r\n\r\n/**\r\n * Logger class for logging messages to the console and optionally to disk.\r\n */\r\nexport class Logger {\r\n  private static noPrint: boolean = false; // Flag to disable console output\r\n\r\n  private static config: LoggerConfig = {\r\n    preserveLogs: false,\r\n  };\r\n\r\n  /**\r\n   * Configures the logger with the provided options.\r\n   * @param {LoggerConfig} config - The configuration settings for the logger.\r\n   */\r\n  static configure(config: LoggerConfig) {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Formats a log message with a timestamp and color based on the log level.\r\n   * @param {LogLevel} level - The log level for the message.\r\n   * @param {string} message - The message to format.\r\n   * @returns {string} - The formatted log message.\r\n   */\r\n  private static formatMessage(level: LogLevel, message: string): string {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = String(now.getMonth() + 1).padStart(2, '0');\r\n    const day = String(now.getDate()).padStart(2, '0');\r\n    const hours = String(now.getHours()).padStart(2, '0');\r\n    const minutes = String(now.getMinutes()).padStart(2, '0');\r\n    const seconds = String(now.getSeconds()).padStart(2, '0');\r\n    const timestamp = `${year}-${month}-${day}:${hours}.${minutes}.${seconds}`;\r\n    if (level === 'special') {\r\n      return `${Colors.reset}${Colors.special}${timestamp} [${level.toUpperCase()}]: \\x1b[31m[${message}\\x1b[31m]${Colors.reset}\\n`;\r\n    }\r\n    return `${Colors.reset}${Colors[level]}${timestamp} [${level.toUpperCase()}]: ${message}${Colors.reset}\\n`;\r\n  }\r\n\r\n  /**\r\n   * Logs a message with the specified log level.\r\n   * @param {LogLevel} level - The log level of the message.\r\n   * @param {string} message - The message to log.\r\n   */\r\n  private static log(level: LogLevel, message: string) {\r\n    const timestamp = new Date().toISOString();\r\n    const formattedMessage = this.formatMessage(level, message);\r\n\r\n    if (!this.noPrint) {\r\n      process.stdout.write(formattedMessage);\r\n    }\r\n\r\n    if (this.config.preserveLogs && this.config.externalCallback) {\r\n      this.config.externalCallback(level, message, timestamp);\r\n    }\r\n  }\r\n\r\n  static special(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('special', msg);\r\n  }\r\n\r\n  static event(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('event', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static debug(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('debug', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs an informational message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static info(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('info', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static warn(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('warn', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs an error message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static error(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('error', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a header message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static header(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('header', msg);\r\n  }\r\n}\r\n\r\n// Default log path for disk logging\r\nconst DEFAULT_LOG_PATH = join(process.cwd(), 'logs');\r\nlet logStream: WriteStream;\r\n\r\n/**\r\n * Generates a log file name based on the current timestamp.\r\n * @returns {string} - The generated log file name.\r\n */\r\nconst getLogFileName = () => {\r\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n  return `dpcp-${timestamp}.log`;\r\n};\r\n\r\n/**\r\n * Initializes the disk logger by creating the log directory and file.\r\n * @returns {boolean} - True if the logger was successfully initialized, otherwise false.\r\n */\r\nconst initDiskLogger = () => {\r\n  try {\r\n    mkdirSync(DEFAULT_LOG_PATH, { recursive: true });\r\n    const logFile = join(DEFAULT_LOG_PATH, getLogFileName());\r\n    logStream = createWriteStream(logFile, { flags: 'a' });\r\n    return true;\r\n  } catch (err) {\r\n    process.stderr.write(`Failed to create log directory: ${err}\\n`);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Default callback function for handling logs that should be preserved.\r\n * @param {LogLevel} level - The log level of the message.\r\n * @param {string} message - The message to log.\r\n * @param {string} timestamp - The timestamp of the log message.\r\n */\r\nconst defaultDiskCallback = (\r\n  level: LogLevel,\r\n  message: string,\r\n  timestamp: string,\r\n) => {\r\n  if (!logStream && !initDiskLogger()) {\r\n    return;\r\n  }\r\n  const plainMessage = `${timestamp} [LOGGER][${level.toUpperCase()}]: ${message}\\n`;\r\n  logStream.write(plainMessage);\r\n};\r\n\r\n// Initial configuration of the logger to preserve logs on disk\r\nLogger.configure({\r\n  preserveLogs: true,\r\n  externalCallback: defaultDiskCallback,\r\n});\r\n","/* eslint-disable no-unused-vars */\r\nimport { Logger } from '../utils/Logger';\r\nimport { PipelineProcessor } from '../core/PipelineProcessor';\r\n\r\nexport type ReportingSignalType = 'local-signal' | 'global-signal';\r\nexport type ProcessorPipeline = PipelineProcessor[];\r\nexport type PipelineData = unknown;\r\nexport interface PipelineMeta {\r\n  header?: unknown;\r\n  resolver?: string;\r\n  monitoringHost?: string;\r\n  configuration: unknown;\r\n}\r\nexport interface CallbackPayload {\r\n  chainId?: string;\r\n  targetId: string;\r\n  data: PipelineData;\r\n  meta?: PipelineMeta;\r\n}\r\nexport type NodeStatusCallback = (payload: any) => void;\r\nexport type ServiceCallback = (payload: CallbackPayload) => void;\r\nexport type SetupCallback = (message: BrodcastSetupMessage) => Promise<void>;\r\nexport type ReportingCallback = (message: ReportingMessage) => Promise<void>;\r\nexport type BroadcastReportingCallback = (\r\n  message: BroadcastReportingMessage,\r\n) => Promise<void>;\r\n\r\nexport namespace DefaultCallback {\r\n  // todo: should be remote_service_callback\r\n  export const SERVICE_CALLBACK: ServiceCallback = (\r\n    payload: CallbackPayload,\r\n  ) => {\r\n    Logger.warn('REMOTE_SERVICE_CALLBACK not set');\r\n  };\r\n  // todo: should be broadcast_setup_callback\r\n  export const SETUP_CALLBACK: SetupCallback = async (\r\n    message: BrodcastSetupMessage,\r\n  ) => {\r\n    Logger.warn('SETUP_CALLBACK not set');\r\n  };\r\n  export const REPORTING_CALLBACK: ReportingCallback = async (\r\n    message: ReportingMessage,\r\n  ) => {\r\n    Logger.warn('REPORTING_CALLBACK not set');\r\n  };\r\n  export const BROADCAST_REPORTING_CALLBACK: ReportingCallback = async (\r\n    message: BroadcastReportingMessage,\r\n  ) => {\r\n    Logger.warn('BROADCAST_REPORTING_CALLBACK not set');\r\n  };\r\n  export const NODE_STATUS_CALLBACK: NodeStatusCallback = async (\r\n    message: NodeStatusMessage,\r\n  ) => {\r\n    Logger.warn('NODE_STATUS_CALLBACK not set');\r\n  };\r\n}\r\n\r\nexport type ProcessorCallback = (\r\n  payload: CallbackPayload,\r\n) => Promise<PipelineData>;\r\n\r\nexport namespace NodeType {\r\n  export type Type = 'local' | 'remote';\r\n  export const LOCAL: Type = 'local';\r\n  export const REMOTE: Type = 'remote';\r\n}\r\n\r\nexport namespace DataType {\r\n  export type Type = 'raw' | 'compressed';\r\n  export const RAW: Type = 'raw';\r\n  export const COMPRESSED: Type = 'compressed';\r\n}\r\n\r\nexport type CombineFonction = (dataSets: PipelineData[]) => unknown[];\r\n\r\nexport interface ChainState {\r\n  completed: string[];\r\n  pending: string[];\r\n  failed: string[];\r\n}\r\n\r\nexport namespace ChainType {\r\n  export type Type = 512 | 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1;\r\n  export const DEFAULT: Type = 1;\r\n  export const PERSISTANT: Type = 2;\r\n  export const AUTO_DELETE: Type = 4;\r\n}\r\n\r\nexport namespace ChainStatus {\r\n  export type Type =\r\n    | 'chain_notified'\r\n    | 'chain_deployed'\r\n    | 'chain_setup_completed'\r\n    | 'node_pending'\r\n    | 'node_in_progress' // running\r\n    | 'node_completed'\r\n    | 'node_failed'\r\n    // | 'node_paused'\r\n    | 'node_resumed'\r\n    | 'node_suspended'\r\n    | 'node_setup_completed'\r\n    | 'child_chain_started'\r\n    | 'child_chain_completed'\r\n    | 'node_pending_deletion'\r\n    | 'node_end_of_pipeline';\r\n  // export const NODE_PAUSED: Type = 'node_paused';\r\n  export const CHAIN_NOTIFIED: Type = 'chain_notified';\r\n  export const CHAIN_DEPLOYED: Type = 'chain_deployed';\r\n  export const CHAIN_SETUP_COMPLETED: Type = 'chain_setup_completed';\r\n  export const NODE_PENDING: Type = 'node_pending';\r\n  export const NODE_IN_PROGRESS: Type = 'node_in_progress';\r\n  export const NODE_COMPLETED: Type = 'node_completed';\r\n  export const NODE_FAILED: Type = 'node_failed';\r\n  export const NODE_SETUP_COMPLETED: Type = 'node_setup_completed';\r\n  export const CHILD_CHAIN_STARTED: Type = 'child_chain_started';\r\n  export const CHILD_CHAIN_COMPLETED: Type = 'child_chain_completed';\r\n  export const NODE_PENDING_DELETION: Type = 'node_pending_deletion';\r\n  export const NODE_END_OF_PIPELINE: Type = 'node_end_of_pipeline';\r\n  export const NODE_SUSPENDED: Type = 'node_suspended';\r\n  export const NODE_RESUMED: Type = 'node_resumed';\r\n}\r\n\r\n// handler signal\r\nexport namespace NodeSignal {\r\n  export type Type =\r\n    // node signals\r\n    | 'node_setup'\r\n    | 'node_create'\r\n    | 'node_delete'\r\n    // | 'node_pause'\r\n    | 'node_suspend'\r\n    // | 'node_delay'\r\n    | 'node_run'\r\n    | 'node_send_data'\r\n    | 'node_error'\r\n    | 'node_resume'\r\n    | 'node_stop'\r\n    // chain signals\r\n    | 'chain_prepare'\r\n    | 'chain_start'\r\n    | 'chain_start_pending_occurrence'\r\n    | 'chain_deploy';\r\n  // node signals\r\n  export const NODE_SETUP: 'node_setup' = 'node_setup';\r\n  export const NODE_CREATE: 'node_create' = 'node_create';\r\n  export const NODE_DELETE: 'node_delete' = 'node_delete';\r\n  // export const NODE_PAUSE: 'node_pause' = 'node_pause';\r\n  // export const NODE_DELAY: 'node_delay' = 'node_delay';\r\n  export const NODE_RUN: 'node_run' = 'node_run';\r\n  export const NODE_SEND_DATA: 'node_send_data' = 'node_send_data';\r\n  export const NODE_ERROR: 'node_error' = 'node_error';\r\n  export const NODE_RESUME: 'node_resume' = 'node_resume';\r\n  export const NODE_STOP: 'node_stop' = 'node_stop';\r\n  export const NODE_SUSPEND: 'node_suspend' = 'node_suspend';\r\n  // chain signals\r\n  export const CHAIN_PREPARE: 'chain_prepare' = 'chain_prepare';\r\n  export const CHAIN_START: 'chain_start' = 'chain_start';\r\n  export const CHAIN_START_PENDING_OCCURRENCE: 'chain_start_pending_occurrence' =\r\n    'chain_start_pending_occurrence';\r\n  export const CHAIN_DEPLOY: 'chain_deploy' = 'chain_deploy';\r\n}\r\n\r\nexport type SupervisorPayloadSetup = {\r\n  signal: 'node_setup';\r\n  config: NodeConfig;\r\n};\r\n\r\nexport type SupervisorPayloadCreate = {\r\n  signal: 'node_create';\r\n  params: NodeConfig;\r\n};\r\n\r\nexport type SupervisorPayloadDelete = {\r\n  signal: 'node_delete';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadRun = {\r\n  signal: 'node_run';\r\n  id: string;\r\n  data: PipelineData;\r\n};\r\n\r\nexport type SupervisorPayloadSendData = {\r\n  signal: 'node_send_data';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadPrepareChain = {\r\n  signal: 'chain_prepare';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadStartChain = {\r\n  signal: 'chain_start';\r\n  id: string;\r\n  data: PipelineData;\r\n};\r\n\r\nexport type SupervisorPayloadStartPendingChain = {\r\n  signal: 'chain_start_pending_occurrence';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadDeployChain = {\r\n  signal: 'chain_deploy';\r\n  config: ChainConfig;\r\n  data: PipelineData;\r\n};\r\n\r\nexport type SupervisorPayload =\r\n  | SupervisorPayloadSetup\r\n  | SupervisorPayloadCreate\r\n  | SupervisorPayloadDelete\r\n  | SupervisorPayloadRun\r\n  | SupervisorPayloadSendData\r\n  | SupervisorPayloadPrepareChain\r\n  | SupervisorPayloadStartChain\r\n  | SupervisorPayloadStartPendingChain\r\n  | SupervisorPayloadDeployChain;\r\n\r\nexport interface ServiceConfig {\r\n  targetId: string;\r\n  meta?: PipelineMeta;\r\n}\r\n\r\nexport enum ChildMode {\r\n  NORMAL = 'normal',\r\n  PARALLEL = 'parallel',\r\n}\r\n\r\nexport type NodeConfig = {\r\n  services: (string | ServiceConfig)[];\r\n  chainId: string;\r\n  index?: number; // automatically set\r\n  count?: number; // automatically set\r\n  location?: NodeType.Type;\r\n  nextTargetId?: string;\r\n  nextMeta?: PipelineMeta;\r\n  chainType?: ChainType.Type;\r\n  monitoringHost?: string;\r\n  childMode?: ChildMode;\r\n  chainConfig?: ChainConfig;\r\n  rootConfig?: NodeConfig;\r\n  signalQueue?: NodeSignal.Type[];\r\n};\r\n\r\nexport type ChainConfig = NodeConfig[];\r\nexport interface BrodcastSetupMessage {\r\n  signal: NodeSignal.Type;\r\n  chain: {\r\n    id: string;\r\n    config: ChainConfig;\r\n  };\r\n}\r\n\r\nexport interface ReportingPayload {\r\n  chainId: string;\r\n  nodeId: string;\r\n  index: number;\r\n  count: number;\r\n}\r\n\r\nexport interface Notification {\r\n  status: ChainStatus.Type;\r\n  signal?: NodeSignal.Type;\r\n  broadcasted?: boolean;\r\n  payload?: unknown;\r\n}\r\n\r\nexport interface ReportingMessage extends ReportingPayload {\r\n  signal: Notification & Partial<NodeStatusMessage>;\r\n}\r\n\r\nexport interface BroadcastReportingMessage extends ReportingPayload {\r\n  signal: Notification;\r\n}\r\n\r\nexport interface NodeStatusMessage extends ReportingPayload {\r\n  signal: NodeSignal.Type;\r\n  payload?: unknown;\r\n}\r\n\r\nexport interface ChainRelation {\r\n  rootNodeId?: string;\r\n  dataRef?: PipelineData;\r\n  config: ChainConfig;\r\n}\r\n","import {\r\n  DataType,\r\n  ChainStatus,\r\n  PipelineData,\r\n  ProcessorPipeline,\r\n  NodeType,\r\n  NodeSignal,\r\n  NodeConfig,\r\n  ChainType,\r\n  PipelineMeta,\r\n  ReportingSignalType,\r\n  Notification,\r\n} from '../types/types';\r\nimport { setImmediate } from 'timers';\r\nimport { randomUUID } from 'node:crypto';\r\nimport { Logger } from '../utils/Logger';\r\nimport { NodeSupervisor } from './NodeSupervisor';\r\nimport { MonitoringAgent, ReportingAgent } from '../agents/MonitoringAgent';\r\nimport { NodeStatusManager } from './NodeStatusManager';\r\n\r\n/**\r\n * Represents a single executable node within a chain\r\n */\r\nexport class Node {\r\n  private id: string;\r\n  private pipelines: ProcessorPipeline[];\r\n  private dependencies: string[];\r\n  private status: ChainStatus.Type;\r\n  private error?: Error;\r\n  private progress: number;\r\n  private dataType: DataType.Type;\r\n  private executionQueue: Promise<void>;\r\n  private output: PipelineData[];\r\n  private nextNodeInfo: {\r\n    id: string;\r\n    type: NodeType.Type;\r\n    meta?: PipelineMeta;\r\n  } | null;\r\n  private config: NodeConfig | null;\r\n  private reporting: ReportingAgent | null = null;\r\n  private statusManager: NodeStatusManager;\r\n\r\n  /**\r\n   * Creates a new Node instance\r\n   * @param {string[]} dependencies - Array of node dependency IDs\r\n   */\r\n  constructor(dependencies: string[] = []) {\r\n    this.id = randomUUID();\r\n    this.output = [];\r\n    this.pipelines = [];\r\n    this.dependencies = dependencies;\r\n    this.status = ChainStatus.NODE_PENDING;\r\n    this.progress = 0;\r\n    this.dataType = DataType.RAW;\r\n    this.executionQueue = Promise.resolve();\r\n    this.nextNodeInfo = null;\r\n    this.config = null;\r\n    this.statusManager = new NodeStatusManager(this);\r\n  }\r\n\r\n  /**\r\n   * Updates the execution progress based on pipeline count\r\n   * @private\r\n   */\r\n  private updateProgress(): void {\r\n    this.progress += 1 / this.pipelines.length;\r\n  }\r\n\r\n  /**\r\n   * Configures the node and sets up monitoring if index is provided\r\n   * @param {NodeConfig} config - Configuration containing services, chainId, index and other options\r\n   */\r\n  setConfig(config: NodeConfig): void {\r\n    const { chainId, index, count } = config;\r\n    if (index !== undefined && count !== undefined) {\r\n      const monitoring = MonitoringAgent.retrieveService();\r\n      this.reporting = monitoring.genReportingAgent({\r\n        chainId,\r\n        nodeId: this.id,\r\n        index,\r\n        count,\r\n      });\r\n    } else {\r\n      Logger.warn('Node index is not defined, configuration failed');\r\n    }\r\n    this.config = config;\r\n    if (config.signalQueue) {\r\n      Logger.info(`Node ${this.id} enqueuing signals...`);\r\n      Logger.debug(`${config.signalQueue}`);\r\n      void this.statusManager.enqueueSignals(config.signalQueue);\r\n    }\r\n  }\r\n\r\n  async enqueueSignals(statusQueue: NodeSignal.Type[]): Promise<void> {\r\n    await this.statusManager.enqueueSignals(statusQueue);\r\n  }\r\n\r\n  /**\r\n   * Gets the node's current execution queue promise\r\n   * @returns {Promise<void>} Current execution queue\r\n   */\r\n  getExecutionQueue(): Promise<void> {\r\n    return this.executionQueue;\r\n  }\r\n\r\n  /**\r\n   * Gets the node's configuration\r\n   * @returns {NodeConfig | null} Node configuration if set\r\n   */\r\n  getConfig(): NodeConfig | null {\r\n    return this.config;\r\n  }\r\n\r\n  /**\r\n   * Gets the node's unique identifier\r\n   * @returns {string} UUID of the node\r\n   */\r\n  getId(): string {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Adds a processor pipeline to the node\r\n   * @param {ProcessorPipeline} pipeline - Array of PipelineProcessor instances\r\n   */\r\n  addPipeline(pipeline: ProcessorPipeline): void {\r\n    this.pipelines.push(pipeline);\r\n  }\r\n\r\n  /**\r\n   * Digest the data through successive processing stages\r\n   * @param {ProcessorPipeline} pipeline - Array of processors to execute\r\n   * @param {PipelineData} data - Data to process\r\n   * @returns {Promise<PipelineData>} Processed data\r\n   * @private\r\n   */\r\n  private async processPipeline(\r\n    pipeline: ProcessorPipeline,\r\n    data: PipelineData,\r\n  ): Promise<PipelineData> {\r\n    let result = data;\r\n    for (const processor of pipeline) {\r\n      result = await processor.digest(result);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Generates pipeline batches of a specified size\r\n   * @param {ProcessorPipeline[]} pipelines - Array of processor pipelines\r\n   * @param {number} count - Number of pipelines per batch\r\n   * @returns {Generator<ProcessorPipeline[], void, unknown>} Generator yielding pipeline batches\r\n   * @private\r\n   */\r\n  private *getPipelineGenerator(\r\n    pipelines: ProcessorPipeline[],\r\n    count: number,\r\n  ): Generator<ProcessorPipeline[], void, unknown> {\r\n    for (let i = 0; i < pipelines.length; i += count) {\r\n      yield pipelines.slice(i, i + count);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notifies about node status changes through the reporting agent\r\n   * @param {ChainStatus.Type} notify - Node status to report\r\n   */\r\n  notify(\r\n    notification: ChainStatus.Type | Notification,\r\n    type: ReportingSignalType = 'local-signal',\r\n  ): void {\r\n    try {\r\n      if (this.reporting !== null) {\r\n        if (typeof notification === 'object' && 'status' in notification) {\r\n          this.reporting.notify(notification, type);\r\n        } else {\r\n          this.reporting.notify({ status: notification }, type);\r\n        }\r\n      } else {\r\n        throw new Error('Reporter not set');\r\n      }\r\n    } catch (error) {\r\n      Logger.error((error as Error).message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes child chains if configured\r\n   * @param {PipelineData} data - Data to be processed by the child chain\r\n   * @returns {Promise<void>}\r\n   * @private\r\n   */\r\n  private async processChildChain(data: PipelineData): Promise<void> {\r\n    const childConfig = this.config?.chainConfig;\r\n\r\n    if (childConfig && Array.isArray(childConfig) && childConfig.length > 0) {\r\n      childConfig[0].rootConfig = this.config\r\n        ? JSON.parse(JSON.stringify(this.config))\r\n        : undefined;\r\n      const supervisor = NodeSupervisor.retrieveService();\r\n      const chainId = await supervisor.handleRequest({\r\n        signal: NodeSignal.CHAIN_DEPLOY,\r\n        config: childConfig,\r\n        data,\r\n      });\r\n\r\n      if (!chainId) {\r\n        throw new Error('Failed to deploy chain: no chainId returned');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes node processing on input data\r\n   * @param {PipelineData} data - Data to process\r\n   * @returns {Promise<void>}\r\n   */\r\n  async execute(data: PipelineData): Promise<void> {\r\n    const childMode =\r\n      this.config?.rootConfig?.childMode === 'parallel'\r\n        ? 'in parallel'\r\n        : 'in serial';\r\n    const suspendedState = this.statusManager.getSuspendedState();\r\n    const isResuming = !!suspendedState;\r\n\r\n    Logger.info(\r\n      `Node ${this.id} execution ${isResuming ? 'resumed' : 'started'} ${childMode}...`,\r\n    );\r\n\r\n    this.executionQueue = this.executionQueue.then(async () => {\r\n      try {\r\n        this.updateStatus(ChainStatus.NODE_IN_PROGRESS);\r\n        let generator: Generator<ProcessorPipeline[], void, unknown>;\r\n        let processingData = data;\r\n\r\n        if (isResuming && suspendedState) {\r\n          generator = suspendedState.generator as Generator<\r\n            ProcessorPipeline[],\r\n            void,\r\n            unknown\r\n          >;\r\n          processingData = suspendedState.data;\r\n          await this.processBatch(suspendedState.currentBatch, processingData);\r\n        } else {\r\n          generator = this.getPipelineGenerator(this.pipelines, 3);\r\n        }\r\n\r\n        let nextResult = isResuming ? generator.next() : generator.next();\r\n\r\n        while (!nextResult.done) {\r\n          const status = await this.statusManager.process();\r\n          if (status.includes(ChainStatus.NODE_SUSPENDED)) {\r\n            this.statusManager.suspendExecution(\r\n              generator,\r\n              nextResult.value,\r\n              processingData,\r\n            );\r\n            return;\r\n          }\r\n\r\n          await this.processBatch(nextResult.value, processingData);\r\n          nextResult = generator.next();\r\n        }\r\n\r\n        this.statusManager.clearSuspendedState();\r\n        this.updateStatus(ChainStatus.NODE_COMPLETED);\r\n\r\n        if (this.config?.chainConfig) {\r\n          Logger.info(`child chain found in node: ${this.id}`);\r\n          await this.processChildChain(processingData);\r\n        }\r\n      } catch (error) {\r\n        if (!this.statusManager.isSuspended()) {\r\n          this.statusManager.clearSuspendedState();\r\n          this.updateStatus(ChainStatus.NODE_FAILED, error as Error);\r\n          Logger.error(`Node ${this.id} execution failed: ${error}`);\r\n        }\r\n      }\r\n    });\r\n\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n    await supervisor.handleRequest({\r\n      signal: NodeSignal.NODE_SEND_DATA,\r\n      id: this.id,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Processes a batch of processor pipelines asynchronously\r\n   * @param {ProcessorPipeline[]} pipelineBatch - Array of processor pipelines to process\r\n   * @param {PipelineData} data - Data to be processed\r\n   * @returns {Promise<void>}\r\n   * @private\r\n   */\r\n  private async processBatch(\r\n    pipelineBatch: ProcessorPipeline[],\r\n    data: PipelineData,\r\n  ): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      setImmediate(async () => {\r\n        try {\r\n          const batchPromises = pipelineBatch.map((pipeline) =>\r\n            this.processPipeline(pipeline, data).then(\r\n              (pipelineData: PipelineData) => {\r\n                this.output.push(pipelineData);\r\n                this.updateProgress();\r\n              },\r\n            ),\r\n          );\r\n          await Promise.all(batchPromises);\r\n          resolve();\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sends processed data to the next node after execution completion\r\n   * @returns {Promise<void>}\r\n   */\r\n  async sendData(): Promise<void> {\r\n    // make sure the queue has finished\r\n    await this.executionQueue;\r\n    Logger.info(`Sending data from node ${this.id}.`);\r\n    await Node.terminate(this.id, this.output);\r\n  }\r\n\r\n  /**\r\n   * Terminates node execution and handles final processed data\r\n   * @param {string} nodeId - Node identifier\r\n   * @param {PipelineData[]} pipelineData - Array of processed data\r\n   * @private\r\n   * @static\r\n   */\r\n  private static async terminate(nodeId: string, pipelineData: PipelineData[]) {\r\n    Logger.special(`Terminate: Node ${nodeId} execution completed.`);\r\n    const data = pipelineData[0];\r\n    await Node.moveToNextNode(nodeId, data);\r\n  }\r\n\r\n  // todo: should not be static\r\n  /**\r\n   * Routes data to next node based on NodeType (LOCAL/REMOTE)\r\n   * @param {string} nodeId - Current node identifier\r\n   * @param {PipelineData} pipelineData - Data to pass forward\r\n   * @private\r\n   * @static\r\n   */\r\n  private static async moveToNextNode(\r\n    nodeId: string,\r\n    pipelineData: PipelineData,\r\n  ) {\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n    const nodes = supervisor.getNodes();\r\n    const currentNode = nodes.get(nodeId);\r\n    const chainId = currentNode?.getConfig()?.chainId;\r\n    if (!currentNode) {\r\n      Logger.warn(`Node ${nodeId} not found for moving to next node.`);\r\n      return;\r\n    }\r\n    const nextNodeInfo = currentNode.getNextNodeInfo();\r\n    if (nextNodeInfo) {\r\n      if (nextNodeInfo.type === NodeType.LOCAL) {\r\n        await supervisor.handleRequest({\r\n          signal: NodeSignal.NODE_RUN,\r\n          id: nextNodeInfo.id,\r\n          data: pipelineData,\r\n        });\r\n      } else if (nextNodeInfo.type === NodeType.REMOTE) {\r\n        supervisor.remoteServiceCallback({\r\n          // targetId and meta are related to the next remote target service uid\r\n          chainId,\r\n          targetId: nextNodeInfo.id,\r\n          data: pipelineData,\r\n          meta: nextNodeInfo.meta,\r\n        });\r\n      }\r\n    } else {\r\n      Logger.special(\r\n        `End of pipeline reached by node ${nodeId} in chain ${chainId}.`,\r\n      );\r\n      currentNode.notify(ChainStatus.NODE_END_OF_PIPELINE, 'global-signal');\r\n    }\r\n    const isPersistant =\r\n      (currentNode.config?.chainType ?? 0) & ChainType.PERSISTANT;\r\n    if (!isPersistant) {\r\n      const autoDelete =\r\n        (currentNode.config?.chainType ?? 0) & ChainType.AUTO_DELETE;\r\n      if (autoDelete) {\r\n        await supervisor.handleRequest({\r\n          id: nodeId,\r\n          signal: NodeSignal.NODE_DELETE,\r\n        });\r\n      } else {\r\n        currentNode.notify(ChainStatus.NODE_PENDING_DELETION, 'global-signal');\r\n      }\r\n    } else {\r\n      Logger.warn(`Node ${nodeId} kept for future calls.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets execution progress value\r\n   * @returns {number} Progress between 0 and 1\r\n   */\r\n  getProgress(): number {\r\n    return this.progress;\r\n  }\r\n\r\n  /**\r\n   * Checks if node dependencies are satisfied\r\n   * @param {Set<string>} executedNodes - Set of completed node IDs\r\n   * @returns {boolean} Whether node can execute\r\n   */\r\n  canExecute(executedNodes: Set<string>): boolean {\r\n    return this.dependencies.every((dep) => executedNodes.has(dep));\r\n  }\r\n\r\n  /**\r\n   * Gets current data type (RAW/COMPRESSED)\r\n   * @returns {DataType.Type} Current data type\r\n   */\r\n  getDataType(): DataType.Type {\r\n    return this.dataType;\r\n  }\r\n\r\n  /**\r\n   * Gets current node status\r\n   * @returns {ChainStatus.Type} Current chain status\r\n   */\r\n  getStatus(): ChainStatus.Type {\r\n    return this.status;\r\n  }\r\n\r\n  /**\r\n   * Gets node dependency IDs\r\n   * @returns {string[]} Array of dependency node IDs\r\n   */\r\n  getDependencies(): string[] {\r\n    return this.dependencies;\r\n  }\r\n\r\n  /**\r\n   * Updates node status and handles error reporting\r\n   * @param {ChainStatus.Type} status - New status to set\r\n   * @param {Error} [error] - Optional error if status is NODE_FAILED\r\n   */\r\n  updateStatus(status: ChainStatus.Type, error?: Error): void {\r\n    this.status = status;\r\n    if (status === ChainStatus.NODE_FAILED) {\r\n      this.error = error;\r\n    }\r\n    if (this.reporting) {\r\n      this.reporting.notify({ status });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets last error if node failed\r\n   * @returns {Error|undefined} Error object if failed\r\n   */\r\n  getError(): Error | undefined {\r\n    return this.error;\r\n  }\r\n\r\n  /**\r\n   * Gets all processor pipelines\r\n   * @returns {ProcessorPipeline[]} Array of processor pipelines\r\n   */\r\n  getProcessors(): ProcessorPipeline[] {\r\n    return this.pipelines;\r\n  }\r\n\r\n  /**\r\n   * Sets next node routing information\r\n   * @param {string} id - Next node ID\r\n   * @param {NodeType.Type} type - Next node type (LOCAL/REMOTE)\r\n   * @param {PipelineMeta} [meta] - Optional pipeline metadata for next node\r\n   */\r\n  setNextNodeInfo(id: string, type: NodeType.Type, meta?: PipelineMeta): void {\r\n    this.nextNodeInfo = { id, type, meta };\r\n  }\r\n\r\n  /**\r\n   * Gets next node routing information\r\n   * @returns {{ id: string, type: NodeType.Type, meta?: PipelineMeta } | null} Next node info or null\r\n   */\r\n  getNextNodeInfo(): {\r\n    id: string;\r\n    type: NodeType.Type;\r\n    meta?: PipelineMeta;\r\n  } | null {\r\n    return this.nextNodeInfo;\r\n  }\r\n}\r\n","import EventEmitter from 'node:events';\r\nimport { randomUUID } from 'node:crypto';\r\n\r\n/**\r\n * Abstract base Agent class that extends EventEmitter\r\n * @abstract\r\n */\r\nexport abstract class Agent extends EventEmitter {\r\n  protected uid: string;\r\n\r\n  /**\r\n   * Creates a new Agent instance with a unique identifier\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.uid = randomUUID();\r\n  }\r\n}\r\n","import { Logger } from '../utils/Logger';\r\nimport { Agent } from './Agent';\r\nimport {\r\n  ChainStatus,\r\n  NodeStatusMessage,\r\n  Notification,\r\n  ReportingSignalType,\r\n} from '../types/types';\r\n\r\n/**\r\n * Abstract base class for a node monitoring and status reporting agent\r\n * @abstract\r\n */\r\nexport abstract class ReportingAgentBase extends Agent {\r\n  private static authorizedAgent: Agent | null = null;\r\n  private status: ChainStatus.Type[] = [];\r\n\r\n  /**\r\n   * Creates a new ReportingAgentBase instance\r\n   * @throws {Error} Throws an error if the agent instantiating this instance is not authorized.\r\n   */\r\n  constructor() {\r\n    super();\r\n    if (!(ReportingAgentBase.authorizedAgent instanceof Agent)) {\r\n      throw new Error(\r\n        'Node Reporter needs to be instantiated by an authorized Agent',\r\n      );\r\n    }\r\n    ReportingAgentBase.authorizedAgent = null;\r\n  }\r\n\r\n  /**\r\n   * Authorizes an agent to create ReportingAgent instances\r\n   * @param {Agent} agent - The agent to authorize\r\n   */\r\n  static authorize(agent: Agent): void {\r\n    ReportingAgentBase.authorizedAgent = agent;\r\n  }\r\n\r\n  /**\r\n   * Notifies about a new chain status\r\n   * @param {ChainStatus.Type} status - The status to notify\r\n   * @param {ReportingSignalType} type - The type of signal ('local-signal' by default)\r\n   */\r\n  notify(\r\n    notification: Notification & Partial<NodeStatusMessage>,\r\n    type: ReportingSignalType = 'local-signal',\r\n  ): void {\r\n    const { status } = notification;\r\n    Logger.info(`Status ${status} from ${this.uid}`);\r\n    this.status.push(status);\r\n    this.emit(type, notification);\r\n  }\r\n\r\n  /**\r\n   * Gets all recorded signals/statuses\r\n   * @returns {ChainStatus.Type[]} Array of recorded chain statuses\r\n   */\r\n  getSignals(): ChainStatus.Type[] {\r\n    return this.status;\r\n  }\r\n}\r\n","import {\r\n  DefaultCallback,\r\n  ReportingCallback,\r\n  ReportingMessage,\r\n  ReportingPayload,\r\n} from '../types/types';\r\nimport { Logger } from '../utils/Logger';\r\nimport { Agent } from './Agent';\r\nimport { ReportingAgentBase } from './ReportingAgent';\r\n\r\n/**\r\n * Class for a node monitoring and status reporting agent\r\n */\r\nexport class ReportingAgent extends ReportingAgentBase {\r\n  /**\r\n   * Creates a new ReportingAgent instance\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {string} nodeId - The node identifier\r\n   */\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    readonly chainId: string,\r\n    // eslint-disable-next-line no-unused-vars\r\n    readonly nodeId: string,\r\n  ) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport interface MonitoringChainStatus {\r\n  [key: string]: {\r\n    [key: string]: boolean;\r\n  };\r\n}\r\nexport interface WorkflowNode {\r\n  status?: MonitoringChainStatus;\r\n  setupCount?: number;\r\n  setupCompleted?: boolean;\r\n  deployed?: boolean;\r\n}\r\n\r\nexport interface Workflow {\r\n  [key: string]: WorkflowNode;\r\n}\r\n\r\n/**\r\n * Responsible for managing all reporting agents and the monitoring of nodes within a processing chain\r\n */\r\nexport class MonitoringAgent extends Agent {\r\n  private static instance: MonitoringAgent;\r\n  private reportingCallback: ReportingCallback;\r\n  private broadcastReportingCallback: ReportingCallback;\r\n  private remoteMonitoringHost: Map<string, string>;\r\n  private workflow: Workflow;\r\n\r\n  /**\r\n   * Creates a new MonitoringAgent instance\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.workflow = {};\r\n    this.remoteMonitoringHost = new Map();\r\n    this.reportingCallback = DefaultCallback.REPORTING_CALLBACK;\r\n    this.broadcastReportingCallback =\r\n      DefaultCallback.BROADCAST_REPORTING_CALLBACK;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the current workflow object\r\n   * @returns {Workflow} The current workflow object\r\n   */\r\n  getWorkflow(): Workflow {\r\n    return this.workflow;\r\n  }\r\n\r\n  /**\r\n   * Retrieves or creates a MonitoringAgent instance (Singleton pattern)\r\n   * @param {boolean} refresh - Whether to force create a new instance\r\n   * @returns {MonitoringAgent} The MonitoringAgent instance\r\n   */\r\n  static retrieveService(refresh: boolean = false): MonitoringAgent {\r\n    if (!MonitoringAgent.instance || refresh) {\r\n      const instance = new MonitoringAgent();\r\n      MonitoringAgent.instance = instance;\r\n    }\r\n    return MonitoringAgent.instance;\r\n  }\r\n\r\n  /**\r\n   * Sets the reporting callback function\r\n   * @param {ReportingCallback} reportingCallback - The callback function to handle reports\r\n   */\r\n  setReportingCallback(reportingCallback: ReportingCallback): void {\r\n    this.reportingCallback = reportingCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the broadcast reporting callback function\r\n   * @param {ReportingCallback} broadcastReportingCallback - The callback function to handle broadcast reports\r\n   */\r\n  setBroadcastReportingCallback(\r\n    broadcastReportingCallback: ReportingCallback,\r\n  ): void {\r\n    this.broadcastReportingCallback = broadcastReportingCallback;\r\n  }\r\n\r\n  /**\r\n   * Gets the remote monitoring host for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {string|undefined} The remote monitoring host address if exists\r\n   */\r\n  getRemoteMonitoringHost(chainId: string): string | undefined {\r\n    return this.remoteMonitoringHost.get(chainId);\r\n  }\r\n\r\n  /**\r\n   * Sets the remote monitoring host for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {string} remoteMonitoringHost - The remote monitoring host address\r\n   */\r\n  setRemoteMonitoringHost(chainId: string, remoteMonitoringHost: string): void {\r\n    this.remoteMonitoringHost.set(chainId, remoteMonitoringHost);\r\n  }\r\n\r\n  /**\r\n   * Generates a new ReportingAgent instance\r\n   * @param {ReportingPayload} payload - The reporting payload containing chainId, nodeId and index\r\n   * @returns {ReportingAgent} A new ReportingAgent instance\r\n   */\r\n  genReportingAgent(payload: ReportingPayload): ReportingAgent {\r\n    const { chainId, nodeId, index } = payload;\r\n    ReportingAgent.authorize(this);\r\n    const reporting = new ReportingAgent(chainId, nodeId);\r\n    // Handle global-signal\r\n    // This is the main process for redirecting signals and communicating with the\r\n    // entire context. It is called after any global notification\r\n    // todo: add type for signals\r\n    reporting.on('global-signal', async (signal) => {\r\n      Logger.event(\r\n        'Receive global-signal:\\n' +\r\n          `\\t\\t\\t\\t${JSON.stringify(signal)}\\n` +\r\n          `\\t\\t\\t\\tfor node ${nodeId}\\n`,\r\n      );\r\n      const message: ReportingMessage = { ...payload, signal };\r\n      if (index > 0) {\r\n        // Report message to distant monitoring host\r\n        signal.broadcasted = true;\r\n        void this.broadcastReportingCallback(message);\r\n      } else {\r\n        // Report message to monitoring\r\n        await this.reportingCallback(message);\r\n      }\r\n    });\r\n\r\n    // handle local signal for a specific node on a specific chain\r\n    reporting.on('local-signal', async (signal) => {\r\n      Logger.event(\r\n        'Receive local-signal:\\n' +\r\n          `\\t\\t\\t\\t${JSON.stringify(signal)}\\n` +\r\n          `\\t\\t\\t\\tfor node ${nodeId} in chain ${chainId}\\n`,\r\n      );\r\n      const message: ReportingMessage = { ...payload, signal };\r\n      const update: MonitoringChainStatus = {\r\n        [message.nodeId]: { [message.signal.status]: true },\r\n      };\r\n      if (!this.workflow[message.chainId]) {\r\n        this.workflow[message.chainId] = {};\r\n      }\r\n      const prev = this.workflow[message.chainId].status || {};\r\n      const next = { ...prev, ...update };\r\n      this.workflow[message.chainId].status = next;\r\n\r\n      if (nodeId === 'supervisor') {\r\n        // Report message to monitoring\r\n        await this.reportingCallback(message);\r\n      }\r\n    });\r\n    return reporting;\r\n  }\r\n\r\n  /**\r\n   * Gets the status for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {ChainStatus|undefined} The chain status if exists\r\n   */\r\n  getChainStatus(chainId: string): MonitoringChainStatus | undefined {\r\n    return this.workflow[chainId]?.status;\r\n  }\r\n\r\n  /**\r\n   * Sets the setup count for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {number} count - The setup count to be set\r\n   */\r\n  setChainSetupCount(chainId: string, count: number): void {\r\n    if (!this.workflow[chainId]) {\r\n      this.workflow[chainId] = {};\r\n    }\r\n    this.workflow[chainId].setupCount = count;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the setup count for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {number|undefined} The setup count if exists\r\n   */\r\n  getChainSetupCount(chainId: string): number | undefined {\r\n    return this.workflow[chainId]?.setupCount;\r\n  }\r\n\r\n  /**\r\n   * Marks a chain as deployed\r\n   * @param {string} chainId - The chain identifier\r\n   */\r\n  setChainDeployed(chainId: string): void {\r\n    if (!this.workflow[chainId]) {\r\n      this.workflow[chainId] = {};\r\n    }\r\n    this.workflow[chainId].deployed = true;\r\n  }\r\n\r\n  /**\r\n   * Checks if a chain is deployed\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {boolean|undefined} Whether the chain is deployed\r\n   */\r\n  getChainDeployed(chainId: string): boolean | undefined {\r\n    return this.workflow[chainId]?.deployed;\r\n  }\r\n\r\n  /**\r\n   * Marks a chain setup as completed\r\n   * @param {string} chainId - The chain identifier\r\n   */\r\n  setChainSetupCompleted(chainId: string): void {\r\n    if (!this.workflow[chainId]) {\r\n      this.workflow[chainId] = {};\r\n    }\r\n    this.workflow[chainId].setupCompleted = true;\r\n  }\r\n\r\n  /**\r\n   * Checks if a chain setup is completed\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {boolean|undefined} Whether the chain setup is completed\r\n   */\r\n  getChainSetupCompleted(chainId: string): boolean | undefined {\r\n    return this.workflow[chainId]?.setupCompleted;\r\n  }\r\n}\r\n","import { NodeSignal, PipelineData, ChainStatus } from '../types/types';\r\nimport { Logger } from '../utils/Logger';\r\nimport { Node } from './Node';\r\n\r\ninterface SuspendedState {\r\n  generator: Generator<any, void, unknown>;\r\n  currentBatch: any;\r\n  data: PipelineData;\r\n}\r\n\r\nexport class NodeStatusManager {\r\n  private signalQueue: NodeSignal.Type[] = [];\r\n  private currentCursor: number = 0;\r\n  private status: ChainStatus.Type[] = [];\r\n\r\n  private suspendedState: SuspendedState | null = null;\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  constructor(private node: Node) {}\r\n\r\n  private async handleStopSignal(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing STOP signal');\r\n  }\r\n\r\n  private async handleSuspendSignal(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing Suspend signal');\r\n    if (!this.status.includes(ChainStatus.NODE_SUSPENDED)) {\r\n      this.status.push(ChainStatus.NODE_SUSPENDED);\r\n      Logger.info(`Node ${this.node.getId()} suspended.`);\r\n    }\r\n  }\r\n\r\n  private async handleResumeSignal(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing RESUME signal');\r\n    const index = this.status.indexOf(ChainStatus.NODE_SUSPENDED);\r\n    if (index > -1) {\r\n      this.status.splice(index, 1);\r\n      if (!this.suspendedState) {\r\n        Logger.warn(\r\n          `~ NodeStatusManager: Node ${this.node.getId()} may have resumed prematurely.`,\r\n        );\r\n        return;\r\n      }\r\n      Logger.info(`~ NodeStatusManager: Resuming node ${this.node.getId()}...`);\r\n      return this.node.execute(this.suspendedState.data);\r\n    } else {\r\n      Logger.warn(\r\n        `~ NodeStatusManager: Cannot resume Node ${this.node.getId()}, not in suspended state.`,\r\n      );\r\n    }\r\n  }\r\n\r\n  suspendExecution<T>(\r\n    generator: Generator<T, void, unknown>,\r\n    currentBatch: T,\r\n    data: PipelineData,\r\n  ): void {\r\n    this.suspendedState = {\r\n      generator,\r\n      currentBatch,\r\n      data,\r\n    };\r\n  }\r\n\r\n  getSuspendedState(): SuspendedState | null {\r\n    return this.suspendedState;\r\n  }\r\n\r\n  clearSuspendedState(): void {\r\n    this.suspendedState = null;\r\n  }\r\n\r\n  isSuspended(): boolean {\r\n    return this.status.includes(ChainStatus.NODE_SUSPENDED);\r\n  }\r\n\r\n  private async handleErrorSignal(): Promise<void> {\r\n    Logger.error('~ NodeStatusManager: Processing ERROR signal');\r\n  }\r\n\r\n  private async handleNodeSetup(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing NODE_SETUP signal');\r\n  }\r\n\r\n  private async handleNodeCreate(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing NODE_CREATE signal');\r\n  }\r\n\r\n  private async handleNodeDelete(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing NODE_DELETE signal');\r\n  }\r\n\r\n  private async handleNodeRun(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing NODE_RUN signal');\r\n  }\r\n\r\n  private async handleNodeSendData(): Promise<void> {\r\n    Logger.info('~ NodeStatusManager: Processing NODE_SEND_DATA signal');\r\n  }\r\n\r\n  public updateQueue(newSignals: NodeSignal.Type[]): void {\r\n    this.signalQueue = newSignals;\r\n    this.currentCursor = 0;\r\n  }\r\n\r\n  public async enqueueSignals(signals: NodeSignal.Type[]): Promise<void> {\r\n    this.signalQueue.push(...signals);\r\n    if (signals.length > 0 && signals[0] === NodeSignal.NODE_RESUME) {\r\n      await this.process();\r\n    }\r\n  }\r\n\r\n  private async processNextSignal(): Promise<void> {\r\n    try {\r\n      const currentSignal = this.signalQueue[this.currentCursor];\r\n      switch (currentSignal) {\r\n        case NodeSignal.NODE_STOP:\r\n          return this.handleStopSignal();\r\n        case NodeSignal.NODE_SUSPEND:\r\n          return this.handleSuspendSignal();\r\n        case NodeSignal.NODE_RESUME:\r\n          return this.handleResumeSignal();\r\n        case NodeSignal.NODE_ERROR:\r\n          return this.handleErrorSignal();\r\n        case NodeSignal.NODE_SETUP:\r\n          return this.handleNodeSetup();\r\n        case NodeSignal.NODE_CREATE:\r\n          return this.handleNodeCreate();\r\n        case NodeSignal.NODE_DELETE:\r\n          return this.handleNodeDelete();\r\n        case NodeSignal.NODE_RUN:\r\n          return this.handleNodeRun();\r\n        case NodeSignal.NODE_SEND_DATA:\r\n          return this.handleNodeSendData();\r\n        default:\r\n          Logger.warn(\r\n            `~ NodeStatusManager: Unknown signal type: ${currentSignal}`,\r\n          );\r\n      }\r\n    } catch (error) {\r\n      Logger.error(\r\n        `~ NodeStatusManager: Error processing signal: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public getQueueState(): { queue: NodeSignal.Type[]; cursor: number } {\r\n    return {\r\n      queue: [...this.signalQueue],\r\n      cursor: this.currentCursor,\r\n    };\r\n  }\r\n\r\n  async process(): Promise<ChainStatus.Type[]> {\r\n    for (; this.currentCursor < this.signalQueue.length; this.currentCursor++) {\r\n      await this.processNextSignal();\r\n    }\r\n    return this.status;\r\n  }\r\n}\r\n","import {\r\n  PipelineData,\r\n  PipelineMeta,\r\n  ProcessorCallback,\r\n  ServiceConfig,\r\n} from 'types/types';\r\nimport { Logger } from '../utils/Logger';\r\n\r\n/**\r\n * Represents a processor that encapsulate external services within a pipeline\r\n */\r\nexport class PipelineProcessor {\r\n  /** Static callback service used by all processor instances */\r\n  static callbackService: ProcessorCallback;\r\n\r\n  /** Optional metadata associated with this processor */\r\n  private meta?: PipelineMeta;\r\n\r\n  /** Target service identifier for this processor */\r\n  private targetId: string;\r\n\r\n  /**\r\n   * Creates a new PipelineProcessor instance\r\n   * @param {ServiceConfig} config - Configuration containing targetId and optional metadata\r\n   */\r\n  constructor(config: ServiceConfig) {\r\n    this.targetId = config.targetId;\r\n    this.meta = config.meta;\r\n  }\r\n\r\n  /**\r\n   * Sets the static callback service used by all processor instances\r\n   * @param {ProcessorCallback} callbackService - The callback function to process data\r\n   */\r\n  static setCallbackService(callbackService: ProcessorCallback): void {\r\n    PipelineProcessor.callbackService = callbackService;\r\n  }\r\n\r\n  /**\r\n   * Processes input data through the callback service\r\n   * @param {PipelineData} data - Data to be processed\r\n   * @returns {Promise<PipelineData>} Processed data\r\n   */\r\n  async digest(data: PipelineData): Promise<PipelineData> {\r\n    if (PipelineProcessor.callbackService) {\r\n      Logger.info(\r\n        `[PipelineProcessor]: Digesting data using \"${this.targetId}\"`,\r\n      );\r\n      return await PipelineProcessor.callbackService({\r\n        targetId: this.targetId,\r\n        meta: this.meta,\r\n        data,\r\n      });\r\n    }\r\n    // Return empty object if no callback service is configured\r\n    return {};\r\n  }\r\n}\r\n","import { Node } from './Node';\r\nimport {\r\n  ServiceCallback,\r\n  NodeSignal,\r\n  ChainStatus,\r\n  PipelineData,\r\n  SupervisorPayload,\r\n  CallbackPayload,\r\n  BrodcastSetupMessage,\r\n  ChainConfig,\r\n  ChainRelation,\r\n  NodeConfig,\r\n  NodeType,\r\n  SetupCallback,\r\n  ServiceConfig,\r\n  DefaultCallback,\r\n  ReportingCallback,\r\n  BroadcastReportingCallback,\r\n  ReportingSignalType,\r\n  Notification,\r\n  ChildMode,\r\n  NodeStatusCallback,\r\n  NodeStatusMessage,\r\n} from '../types/types';\r\nimport { Logger } from '../utils/Logger';\r\nimport { PipelineProcessor } from './PipelineProcessor';\r\nimport { randomUUID } from 'node:crypto';\r\nimport { MonitoringAgent } from '../agents/MonitoringAgent';\r\nimport { NodeSupervisorLogger } from './NodeSupervisorLogger';\r\n\r\n/**\r\n * Manages the lifecycle and distribution of nodes within a processing chain\r\n */\r\nexport class NodeSupervisor {\r\n  private uid: string;\r\n  private ctn: string;\r\n  private static instance: NodeSupervisor;\r\n  private nsLogger: NodeSupervisorLogger;\r\n  private nodes: Map<string, Node>; // local nodes\r\n  private chains: Map<string, ChainRelation>; // local chains\r\n  private childChains: Map<string, string[]>; // map children to parents\r\n  private broadcastSetupCallback: SetupCallback;\r\n  nodeStatusCallback: NodeStatusCallback;\r\n  remoteServiceCallback: ServiceCallback;\r\n\r\n  /**\r\n   * Creates a new NodeSupervisor instance\r\n   * @private\r\n   */\r\n  private constructor() {\r\n    this.uid = '@supervisor:default';\r\n    this.ctn = '@container:default';\r\n    this.nsLogger = new NodeSupervisorLogger();\r\n    this.nodes = new Map();\r\n    this.chains = new Map();\r\n    this.childChains = new Map();\r\n    this.remoteServiceCallback = DefaultCallback.SERVICE_CALLBACK;\r\n    this.broadcastSetupCallback = DefaultCallback.SETUP_CALLBACK;\r\n    this.nodeStatusCallback = DefaultCallback.NODE_STATUS_CALLBACK;\r\n  }\r\n\r\n  /**\r\n   * Retrieves or creates a NodeSupervisor instance (Singleton pattern)\r\n   * @param {boolean} refresh - Whether to force create a new instance\r\n   * @returns {NodeSupervisor} The NodeSupervisor instance\r\n   */\r\n  static retrieveService(refresh: boolean = false): NodeSupervisor {\r\n    if (!NodeSupervisor.instance || refresh) {\r\n      const instance = new NodeSupervisor();\r\n      NodeSupervisor.instance = instance;\r\n    }\r\n    return NodeSupervisor.instance;\r\n  }\r\n\r\n  log(type: string) {\r\n    switch (type) {\r\n      case 'chains':\r\n        this.nsLogger.logChains(this.chains);\r\n        break;\r\n      case 'monitoring-workflow': {\r\n        const monitoring = MonitoringAgent.retrieveService();\r\n        const workflow = monitoring.getWorkflow();\r\n        this.nsLogger.logWorkflow(workflow);\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  getChain(chainId: string): ChainRelation | undefined {\r\n    return this.chains.get(chainId);\r\n  }\r\n\r\n  setNodeStatusCallback(nodeStatusCallback: NodeStatusCallback): void {\r\n    this.nodeStatusCallback = nodeStatusCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the remote service callback function\r\n   * @param {ServiceCallback} remoteServiceCallback - The callback to handle remote service calls\r\n   */\r\n  setRemoteServiceCallback(remoteServiceCallback: ServiceCallback): void {\r\n    this.remoteServiceCallback = remoteServiceCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the broadcast setup callback function\r\n   * @param {SetupCallback} broadcastSetupCallback - The callback to handle broadcast setup signals\r\n   */\r\n  setBroadcastSetupCallback(broadcastSetupCallback: SetupCallback): void {\r\n    this.broadcastSetupCallback = broadcastSetupCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the broadcast reporting callback function\r\n   * @param {BroadcastReportingCallback} broadcastReportingCallback - The callback to handle broadcast reporting signals\r\n   */\r\n  setBroadcastReportingCallback(\r\n    broadcastReportingCallback: BroadcastReportingCallback,\r\n  ): void {\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    monitoring.setBroadcastReportingCallback(broadcastReportingCallback);\r\n  }\r\n\r\n  /**\r\n   * Sets the monitoring reporting callback function\r\n   * @param {ReportingCallback} reportingCallback - The callback to handle monitoring reports\r\n   */\r\n  setMonitoringCallback(reportingCallback: ReportingCallback): void {\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    monitoring.setReportingCallback(reportingCallback);\r\n  }\r\n\r\n  /**\r\n   * Sets the unique identifier for this supervisor instance\r\n   * @param {string} uid - The unique identifier\r\n   */\r\n  setUid(uid: string) {\r\n    this.ctn = `@container:${uid}`;\r\n    this.uid = `@supervisor:${uid}`;\r\n  }\r\n\r\n  async enqueueSignals(\r\n    nodeId: string,\r\n    status: NodeSignal.Type[],\r\n  ): Promise<void> {\r\n    return this.nodes.get(nodeId)?.enqueueSignals(status);\r\n  }\r\n\r\n  /**\r\n   * Handles supervisor requests (node setup, creation, deletion, etc.)\r\n   * @param {SupervisorPayload} payload - The request payload\r\n   * @returns {Promise<void|string>} Promise resolving to a string if applicable\r\n   */\r\n  async handleRequest(payload: SupervisorPayload): Promise<void | string> {\r\n    switch (payload.signal) {\r\n      case NodeSignal.NODE_SETUP:\r\n        Logger.event(`handle NODE_SETUP`);\r\n        return await this.setupNode(payload.config);\r\n      case NodeSignal.NODE_CREATE:\r\n        Logger.event(`handle NODE_CREATE`);\r\n        return await this.createNode(payload.params);\r\n      case NodeSignal.NODE_DELETE:\r\n        Logger.event(`handle NODE_DELETE`);\r\n        return await this.deleteNode(payload.id);\r\n      case NodeSignal.NODE_RUN:\r\n        Logger.event(`handle NODE_RUN`);\r\n        return await this.runNode(payload.id, payload.data);\r\n      case NodeSignal.NODE_SEND_DATA:\r\n        Logger.event(`handle NODE_SEND_DATA`);\r\n        return await this.sendNodeData(payload.id);\r\n      case NodeSignal.CHAIN_PREPARE:\r\n        Logger.event(`handle CHAIN_PREPARE`);\r\n        return await this.prepareChainDistribution(payload.id);\r\n      case NodeSignal.CHAIN_START:\r\n        Logger.event(`handle CHAIN_START`);\r\n        return await this.startChain(payload.id, payload.data);\r\n      case NodeSignal.CHAIN_START_PENDING_OCCURRENCE:\r\n        Logger.event(`handle CHAIN_START_PENDING_OCCURRENCE`);\r\n        return await this.startPendingChain(payload.id);\r\n      case NodeSignal.CHAIN_DEPLOY: {\r\n        Logger.event(`handle CHAIN_DEPLOY`);\r\n        return await this.deployChain(payload.config, payload.data);\r\n      }\r\n      default:\r\n        Logger.warn(\r\n          `${this.ctn}: Unknown signal received: ${JSON.stringify(payload, null, 2)}`,\r\n        );\r\n    }\r\n  }\r\n\r\n  remoteReport(\r\n    notification: Notification & Partial<NodeStatusMessage>,\r\n    chainId: string,\r\n  ) {\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    const reporting = monitoring.genReportingAgent({\r\n      chainId,\r\n      nodeId: 'supervisor-remote',\r\n      index: 1,\r\n      count: -1,\r\n    });\r\n    reporting.notify(notification, 'global-signal');\r\n  }\r\n\r\n  private localReport(status: ChainStatus.Type, chainId: string) {\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    const reporting = monitoring.genReportingAgent({\r\n      chainId,\r\n      nodeId: 'supervisor',\r\n      index: -1,\r\n      count: -1,\r\n    });\r\n    reporting.notify({ status }, 'local-signal');\r\n  }\r\n\r\n  /**\r\n   * Deploys a new processing chain\r\n   * @param {ChainConfig} config - Configuration for the new chain\r\n   * @param {PipelineData} data - Initial data to start the chain\r\n   * @returns {Promise<string>} The new chain identifier\r\n   */\r\n  private async deployChain(\r\n    config: ChainConfig,\r\n    data: PipelineData,\r\n    parentChainId?: string,\r\n  ): Promise<string> {\r\n    try {\r\n      if (!config) {\r\n        throw new Error(`${this.ctn}: Chain configuration is required`);\r\n      }\r\n      Logger.info(`${this.ctn}: Starting a new chain deployment...`);\r\n      const chainId = this.createChain(config);\r\n      await this.prepareChainDistribution(chainId);\r\n      const chain = this.chains.get(chainId);\r\n      if (chain) {\r\n        chain.dataRef = data;\r\n      }\r\n      Logger.info(\r\n        `${this.ctn}: Deployment for chain ${chainId} has successfully started...`,\r\n      );\r\n      if (parentChainId) {\r\n        const children = this.childChains.get(parentChainId) || [];\r\n        children.push(chainId);\r\n        this.childChains.set(parentChainId, children);\r\n      }\r\n      this.localReport(ChainStatus.CHAIN_DEPLOYED, chainId);\r\n      return chainId;\r\n    } catch (error) {\r\n      Logger.error(`${this.ctn}{deployChain}: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new node with the given configuration\r\n   * @param {NodeConfig} config - The node configuration\r\n   * @returns {Promise<string>} The new node identifier\r\n   */\r\n  private async createNode(config: NodeConfig): Promise<string> {\r\n    const node = new Node();\r\n    const nodeId = node.getId();\r\n    node.setConfig(config);\r\n    this.nodes.set(nodeId, node);\r\n    Logger.info(\r\n      `${this.ctn}: Node ${nodeId} created with config: ${JSON.stringify(config, null, 2)}`,\r\n    );\r\n    return nodeId;\r\n  }\r\n\r\n  /**\r\n   * Sets up a new node with the given configuration\r\n   * @param {NodeConfig} config - The node configuration\r\n   * @param {boolean} initiator - Whether the node is the chain initiator\r\n   * @returns {Promise<string>} The new node identifier\r\n   */\r\n  private async setupNode(\r\n    config: NodeConfig,\r\n    initiator: boolean = false,\r\n  ): Promise<string> {\r\n    this.updateChain([config]);\r\n    const nodeId = await this.createNode(config);\r\n    const node = this.nodes.get(nodeId);\r\n\r\n    if (!node) {\r\n      Logger.warn(`${this.ctn}: Attempted to setup undefined node`);\r\n      return nodeId;\r\n    }\r\n\r\n    Logger.header(`Setup node ${node?.getId()}...`);\r\n    await this.setRemoteMonitoringHost(config);\r\n\r\n    const processors = config.services.map(\r\n      (service) =>\r\n        new PipelineProcessor(\r\n          typeof service === 'string' ? { targetId: service } : service,\r\n        ),\r\n    );\r\n    await this.addProcessors(nodeId, processors);\r\n    Logger.info(\r\n      `${this.ctn}: Node ${nodeId} setup completed with ${processors.length} processors`,\r\n    );\r\n\r\n    if (config.nextTargetId !== undefined) {\r\n      node.setNextNodeInfo(\r\n        config.nextTargetId,\r\n        NodeType.REMOTE,\r\n        config.nextMeta,\r\n      );\r\n    } else if (!initiator) {\r\n      Logger.warn(\r\n        `${this.ctn}: Cannot set next node info: nextTargetId is undefined`,\r\n      );\r\n    }\r\n    //\r\n    this.notify(nodeId, ChainStatus.NODE_SETUP_COMPLETED, 'global-signal');\r\n    return nodeId;\r\n  }\r\n\r\n  /**\r\n   * Handles externals notifications about a chain status change\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {Notification} notification - The new chain status notification\r\n   */\r\n  handleNotification(chainId: string, notification: Notification): void {\r\n    try {\r\n      const chain = this.chains.get(chainId);\r\n      if (!chain) {\r\n        Logger.warn(`${this.ctn}: Chain with ID ${chainId} not found.`);\r\n        return;\r\n      }\r\n      const rootNodeId = chain.rootNodeId;\r\n      if (!rootNodeId) {\r\n        Logger.warn(`${this.ctn}: Root node ID missing for chain ${chainId}.`);\r\n        return;\r\n      }\r\n      const node = this.nodes.get(rootNodeId);\r\n      if (!node) {\r\n        Logger.warn(`${this.ctn}: Node with ID ${rootNodeId} not found.`);\r\n        return;\r\n      }\r\n      Logger.info(\r\n        `${this.ctn}:\\n\\t\\tSending notification to node ${rootNodeId}` +\r\n          `\\n\\t\\twith status ${JSON.stringify(notification)}.`,\r\n      );\r\n      node.notify(notification, 'global-signal');\r\n    } catch (error) {\r\n      Logger.error(\r\n        `${this.ctn}: Failed to handle notification for chain ${chainId}: ${(error as Error).message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notifies a node about a chain status change\r\n   * @param {string} nodeId - The node identifier to notify\r\n   * @param {ChainStatus.Type} status - The new chain status to notify\r\n   */\r\n  private notify(\r\n    nodeId: string,\r\n    status: ChainStatus.Type,\r\n    type: ReportingSignalType = 'local-signal',\r\n  ): void {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      node.notify(status, type);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Can't notify non-existing node ${nodeId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds processors to a node\r\n   * @param {string} nodeId - The node identifier\r\n   * @param {PipelineProcessor[]} processors - Array of processors to add\r\n   */\r\n  async addProcessors(\r\n    nodeId: string,\r\n    processors: PipelineProcessor[],\r\n  ): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      node.addPipeline(processors);\r\n      Logger.info(`${this.ctn}: Processors added to Node ${nodeId}.`);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a node\r\n   * @param {string} nodeId - The node identifier to delete\r\n   */\r\n  private async deleteNode(nodeId: string): Promise<void> {\r\n    if (this.nodes.has(nodeId)) {\r\n      this.nodes.delete(nodeId);\r\n      Logger.info(`${this.ctn}: Node ${nodeId} deleted.`);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new chain with the given configuration\r\n   * @param {ChainConfig} config - The chain configuration\r\n   * @returns {string} The new chain identifier\r\n   */\r\n  createChain(config: ChainConfig): string {\r\n    try {\r\n      if (!config || !Array.isArray(config)) {\r\n        throw new Error('Invalid chain configuration: config must be an array');\r\n      }\r\n      const timestamp = Date.now();\r\n      const chainId = `${this.uid}-${timestamp}-${randomUUID().slice(0, 8)}`;\r\n      const relation: ChainRelation = {\r\n        config,\r\n      };\r\n\r\n      this.chains.set(chainId, relation);\r\n\r\n      let monitoringHost = config[0].rootConfig\r\n        ? config[0].rootConfig.monitoringHost\r\n        : config[0]?.monitoringHost;\r\n\r\n      const count = Array.isArray(config) ? config.length : 0;\r\n\r\n      if (count > 0) {\r\n        config.forEach((value: NodeConfig, index: number) => {\r\n          if (value) {\r\n            value.index = index;\r\n            value.count = count;\r\n            value.monitoringHost = monitoringHost;\r\n          }\r\n        });\r\n      } else {\r\n        Logger.warn(`${this.ctn}: Chain configuration is empty`);\r\n      }\r\n\r\n      Logger.header(`${this.ctn}:\\n\\tChain ${chainId} creation has started...`);\r\n      return chainId;\r\n    } catch (error) {\r\n      Logger.header(`${this.ctn}{createChain}:\\n\\t${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates an existing chain with new configurations\r\n   * @param {ChainConfig} config - The new chain configurations to add\r\n   * @returns {string} The chain identifier\r\n   */\r\n  private updateChain(config: ChainConfig): string {\r\n    if (config.length === 0 || !config[0].chainId) {\r\n      throw new Error('Invalid chain configuration');\r\n    }\r\n    const chainId = config[0].chainId;\r\n    let relation = this.chains.get(chainId);\r\n\r\n    if (relation) {\r\n      // todo: to be reviewed\r\n      relation.config = relation.config.concat(config);\r\n      Logger.info(\r\n        `${this.ctn}: Chain ${chainId} updated with ${config.length} new configurations`,\r\n      );\r\n    } else {\r\n      relation = {\r\n        config: config,\r\n      };\r\n      this.chains.set(chainId, relation);\r\n      Logger.info(\r\n        `${this.ctn}: Chain ${chainId} created with ${config.length} configurations`,\r\n      );\r\n    }\r\n    return chainId;\r\n  }\r\n\r\n  /**\r\n   * Sets the remote monitoring host for a chain\r\n   * @param {NodeConfig} config - The node configuration containing the monitoring host\r\n   */\r\n  private async setRemoteMonitoringHost(config: NodeConfig): Promise<void> {\r\n    const remoteMonitoringHost = config.monitoringHost;\r\n    if (!remoteMonitoringHost) {\r\n      throw new Error(\r\n        `${this.ctn}: No Monitoring Host set for Chain ${config.chainId} during distribution`,\r\n      );\r\n    }\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    monitoring.setRemoteMonitoringHost(config.chainId, remoteMonitoringHost);\r\n  }\r\n\r\n  /**\r\n   * Prepares the distribution of a processing chain\r\n   * @param {string} chainId - The chain identifier\r\n   */\r\n  async prepareChainDistribution(chainId: string): Promise<void> {\r\n    try {\r\n      Logger.header(\r\n        `${this.ctn}:\\n\\tChain distribution for ${chainId} in progress...`,\r\n      );\r\n      const chain = this.chains.get(chainId);\r\n      if (!chain) {\r\n        throw new Error(`${this.ctn}: Chain ${chainId} not found`);\r\n      }\r\n      const chainConfig: ChainConfig = chain.config;\r\n      const localConfigs: NodeConfig[] = chainConfig.filter(\r\n        (config) => config.location === 'local',\r\n      );\r\n      const remoteConfigs: NodeConfig[] = chainConfig.filter(\r\n        (config) => config.location === 'remote',\r\n      );\r\n\r\n      if (!localConfigs) {\r\n        Logger.warn('Local config undefined');\r\n      }\r\n\r\n      if (localConfigs.length > 0) {\r\n        const rootNodeId = await this.setupNode(\r\n          { ...localConfigs[0], chainId },\r\n          true,\r\n        );\r\n        chain.rootNodeId = rootNodeId;\r\n\r\n        let prevNodeId = rootNodeId;\r\n        for (let i = 1; i < localConfigs.length; i++) {\r\n          const currentNodeId = await this.setupNode(\r\n            {\r\n              ...localConfigs[i],\r\n              chainId,\r\n            },\r\n            true,\r\n          );\r\n          const prevNode = this.nodes.get(prevNodeId);\r\n          if (prevNode) {\r\n            prevNode.setNextNodeInfo(currentNodeId, NodeType.LOCAL);\r\n          }\r\n          prevNodeId = currentNodeId;\r\n        }\r\n\r\n        if (!remoteConfigs) {\r\n          Logger.warn('Remote config undefined');\r\n        }\r\n\r\n        // Set the last local node to point to the first remote service\r\n        if (remoteConfigs.length > 0 && remoteConfigs[0].services.length > 0) {\r\n          const lastLocalNode = this.nodes.get(prevNodeId);\r\n          if (lastLocalNode) {\r\n            const nextService = remoteConfigs[0].services[0];\r\n            lastLocalNode.setNextNodeInfo(\r\n              typeof nextService === 'string'\r\n                ? nextService\r\n                : nextService.targetId,\r\n              NodeType.REMOTE,\r\n              typeof nextService === 'string' ? void 0 : nextService.meta,\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        Logger.warn(\r\n          `${this.ctn}: No local config found for chain ${chainId}. Root node unavailable.`,\r\n        );\r\n      }\r\n      try {\r\n        if (remoteConfigs.length > 0) {\r\n          const updatedRemoteConfigs: NodeConfig[] = remoteConfigs.map(\r\n            (config, index) => {\r\n              const nextConfig: string | ServiceConfig =\r\n                remoteConfigs[index + 1]?.services[0];\r\n              const nodeConfig: NodeConfig = {\r\n                ...config,\r\n                nextTargetId: nextConfig\r\n                  ? typeof nextConfig === 'string'\r\n                    ? nextConfig\r\n                    : nextConfig.targetId\r\n                  : undefined,\r\n                nextMeta:\r\n                  nextConfig && typeof nextConfig !== 'string'\r\n                    ? nextConfig.meta\r\n                    : undefined,\r\n              };\r\n              return nodeConfig;\r\n            },\r\n          );\r\n          await this.broadcastNodeSetupSignal(chainId, updatedRemoteConfigs);\r\n        }\r\n      } catch (error) {\r\n        Logger.error(\r\n          `${this.ctn}{prepareChainDistribution, broadcast}: ${(error as Error).message}`,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      Logger.error(\r\n        `${this.ctn}{prepareChainDistribution}: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcasts a setup signal for remote nodes in a chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {ChainConfig} remoteConfigs - The remote node configurations\r\n   */\r\n  async broadcastNodeSetupSignal(\r\n    chainId: string,\r\n    remoteConfigs: ChainConfig,\r\n  ): Promise<void> {\r\n    const message: BrodcastSetupMessage = {\r\n      signal: NodeSignal.NODE_SETUP,\r\n      chain: {\r\n        id: chainId,\r\n        config: remoteConfigs,\r\n      },\r\n    };\r\n\r\n    try {\r\n      await this.broadcastSetupCallback(message);\r\n      Logger.info(\r\n        `${this.ctn}: Node creation signal broadcasted with chainId: ${chainId} for remote configs`,\r\n      );\r\n    } catch (error) {\r\n      Logger.error(\r\n        `${this.ctn}: Failed to broadcast node creation signal: ${error}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts a pending chain\r\n   * @param {string} chainId - The chain identifier\r\n   */\r\n  async startPendingChain(chainId: string) {\r\n    const chain = this.chains.get(chainId);\r\n    const data = chain?.dataRef;\r\n\r\n    if (data) {\r\n      const rootConfig = chain?.config[0]?.rootConfig;\r\n      if (rootConfig) {\r\n        const rootNodeId = chain?.rootNodeId;\r\n        if (!rootNodeId) {\r\n          Logger.error(\r\n            `${this.ctn}: Root node ID for chain ${chainId} not found.`,\r\n          );\r\n          throw new Error('Root node ID not found');\r\n        }\r\n        const chainMode =\r\n          chain?.config[0]?.rootConfig?.childMode === 'parallel'\r\n            ? 'parallel'\r\n            : 'serial';\r\n\r\n        if (chainMode === ChildMode.PARALLEL) {\r\n          Logger.warn(`// Starting parallel child chain: ${chainId}`);\r\n          this.notify(\r\n            rootNodeId,\r\n            ChainStatus.CHILD_CHAIN_STARTED,\r\n            'global-signal',\r\n          );\r\n\r\n          this.startChain(chainId, data)\r\n            .then(() =>\r\n              this.notify(\r\n                rootNodeId,\r\n                ChainStatus.CHILD_CHAIN_COMPLETED,\r\n                'global-signal',\r\n              ),\r\n            )\r\n            .catch((error) => {\r\n              Logger.error(`Failed to start parallel child chain: ${error}`);\r\n            });\r\n        } else {\r\n          Logger.warn(`__ Starting serial child chain: ${chainId}`);\r\n          await this.startChain(chainId, data);\r\n          this.notify(\r\n            rootNodeId,\r\n            ChainStatus.CHILD_CHAIN_COMPLETED,\r\n            'global-signal',\r\n          );\r\n        }\r\n      } else {\r\n        await this.startChain(chainId, data);\r\n      }\r\n    } else {\r\n      Logger.warn(`${this.ctn}:\\n\\tNothing to process on chain ${chainId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts a new chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {PipelineData} data - The initial data to process\r\n   */\r\n  async startChain(chainId: string, data: PipelineData): Promise<void> {\r\n    Logger.header(`<<Start Chain>>: Chain ${chainId} requested...`);\r\n    Logger.info(`Data: ${JSON.stringify(data, null, 2)}`);\r\n    const chain = this.chains.get(chainId);\r\n    if (!chain) {\r\n      Logger.warn(`Chain ${chainId} not found.`);\r\n      return;\r\n    }\r\n    const rootNodeId = chain.rootNodeId;\r\n    if (!rootNodeId) {\r\n      Logger.error(`${this.ctn}: Root node ID for chain ${chainId} not found.`);\r\n      return;\r\n    }\r\n\r\n    const rootNode = this.nodes.get(rootNodeId);\r\n\r\n    if (!rootNode) {\r\n      Logger.error(\r\n        `${this.ctn}: Root node ${rootNodeId} for chain ${chainId} not found.`,\r\n      );\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await this.runNode(rootNodeId, data);\r\n      Logger.info(\r\n        `${this.ctn}: Chain ${chainId} started with root node ${rootNodeId}.`,\r\n      );\r\n    } catch (error) {\r\n      Logger.error(`${this.ctn}: Failed to start chain ${chainId}: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a node with the given data\r\n   * @param {string} nodeId - The node identifier\r\n   * @param {PipelineData} data - The data to process\r\n   */\r\n  private async runNode(nodeId: string, data: PipelineData): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      await node.execute(data);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a node based on the given callback payload\r\n   * @param {CallbackPayload} payload - The payload containing target ID, chain ID, and data\r\n   */\r\n  async runNodeByRelation(payload: CallbackPayload): Promise<void> {\r\n    try {\r\n      const { targetId, chainId, data } = payload;\r\n      Logger.info(`Received data for node hosting target ${targetId}`);\r\n      if (chainId === undefined) {\r\n        throw new Error('chainId is undefined');\r\n      }\r\n      if (targetId === undefined) {\r\n        throw new Error('targetId is undefined');\r\n      }\r\n      const node = this.getNodesByServiceAndChain(targetId, chainId);\r\n      if (!node || node.length === 0) {\r\n        throw new Error(\r\n          `No node found for targetId ${targetId} and chainId ${chainId}`,\r\n        );\r\n      }\r\n      const nodeId = node[0].getId();\r\n      if (nodeId === undefined) {\r\n        throw new Error(\r\n          `No node ID exists for targetId ${targetId} and chainId ${chainId}`,\r\n        );\r\n      }\r\n      await this.handleRequest({\r\n        signal: NodeSignal.NODE_RUN,\r\n        id: nodeId,\r\n        data: data as PipelineData,\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error in runNodeByRelation: ${(error as Error).message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends data from a node\r\n   * @param {string} nodeId - The node identifier\r\n   */\r\n  private async sendNodeData(nodeId: string): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      try {\r\n        await node.sendData();\r\n      } catch (err) {\r\n        const error = err as Error;\r\n        Logger.error(\r\n          `${this.ctn}: Node ${nodeId} send data failed: ${error.message}`,\r\n        );\r\n      }\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets all the nodes managed by this supervisor\r\n   * @returns {Map<string, Node>} Map of nodes\r\n   */\r\n  getNodes(): Map<string, Node> {\r\n    return this.nodes;\r\n  }\r\n\r\n  /**\r\n   * Gets all nodes associated with a specific service and chain\r\n   * @param {string} serviceUid - The service identifier\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {Node[]} Array of nodes matching the criteria\r\n   */\r\n  getNodesByServiceAndChain(serviceUid: string, chainId: string): Node[] {\r\n    return Array.from(this.nodes.values()).filter((node) => {\r\n      const nodeConfig = node.getConfig();\r\n      if (!nodeConfig) {\r\n        return false;\r\n      }\r\n      return (\r\n        nodeConfig.chainId === chainId &&\r\n        nodeConfig.services.some((service) =>\r\n          typeof service === 'string'\r\n            ? service === serviceUid\r\n            : service.targetId === serviceUid,\r\n        )\r\n      );\r\n    });\r\n  }\r\n}\r\n","import { Logger } from '../utils/Logger';\r\nimport { ChainRelation } from '../types/types';\r\nimport { Workflow } from '../agents/MonitoringAgent';\r\n\r\nexport class NodeSupervisorLogger {\r\n  constructor() {}\r\n  logChains(chains: Map<string, ChainRelation>) {\r\n    Logger.debug('--Logging chains content:');\r\n    chains.forEach((relation, chainId) => {\r\n      Logger.debug(`Chain ID: ${chainId}`);\r\n      Logger.debug(`Root Node ID: ${relation.rootNodeId || 'None'}`);\r\n      Logger.debug(\r\n        `Data Reference: ${JSON.stringify(relation.dataRef, null, 2) || 'None'}`,\r\n      );\r\n      Logger.debug('Chain Configuration:');\r\n      relation.config.forEach((nodeConfig, index) => {\r\n        Logger.debug(`  Node ${index + 1}:`);\r\n        Logger.debug(`    Services: ${JSON.stringify(nodeConfig.services)}`);\r\n        Logger.debug(`    Chain ID: ${nodeConfig.chainId}`);\r\n        Logger.debug(`    Index: ${nodeConfig.index}`);\r\n        Logger.debug(`    Count: ${nodeConfig.count}`);\r\n        Logger.debug(`    Location: ${nodeConfig.location}`);\r\n        Logger.debug(`    Next Target ID: ${nodeConfig.nextTargetId}`);\r\n        Logger.debug(`    Chain Type: ${nodeConfig.chainType}`);\r\n        Logger.debug(`    Monitoring Host: ${nodeConfig.monitoringHost}`);\r\n        Logger.debug(`    Child Mode: ${nodeConfig.childMode}`);\r\n      });\r\n    });\r\n  }\r\n\r\n  logWorkflow(workflow: Workflow) {\r\n    Logger.debug('--Logging chains content:');\r\n    Object.entries(workflow).forEach(([workflowId, node]) => {\r\n      Logger.header(`Workflow Node: ${workflowId}`);\r\n      Object.entries(node).forEach(([key, value]) => {\r\n        Logger.debug(`- ${key}: ${JSON.stringify(value)}`);\r\n      });\r\n    });\r\n  }\r\n}\r\n","import {\r\n  ChainStatus,\r\n  NodeSignal,\r\n  NodeStatusMessage,\r\n  ReportingMessage,\r\n  SupervisorPayloadStartPendingChain,\r\n} from '../types/types';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { MonitoringAgent } from '../agents/MonitoringAgent';\r\nimport { Logger } from '../utils/Logger';\r\n\r\nexport namespace Ext {\r\n  /**\r\n   * Default class, responsible for handling monitoring signals.\r\n   * Processes reporting messages and triggers actions based on the message signal.\r\n   */\r\n  export class MonitoringSignalHandler {\r\n    /**\r\n     * Triggers the pending occurrence workflow by sending a signal to the supervisor\r\n     * @private\r\n     * @static\r\n     * @param {string} chainId - The ID of the chain\r\n     * @returns {Promise<void>}\r\n     */\r\n    private static async triggerPendingOccurrence(chainId: string) {\r\n      const supervisor = NodeSupervisor.retrieveService();\r\n      const payload: SupervisorPayloadStartPendingChain = {\r\n        signal: NodeSignal.CHAIN_START_PENDING_OCCURRENCE,\r\n        id: chainId,\r\n      };\r\n      await supervisor.handleRequest(payload);\r\n      Logger.event(`MonitoringSignalHandler: Start Pending Occurrence...`);\r\n    }\r\n\r\n    /**\r\n     * Handles a reporting message and triggers appropriate actions based on the signal type.\r\n     * This function serves as a flexible entry point for processing intercepted signals\r\n     * originating from the reporting agent, allowing adaptation system needs.\r\n     * Specifically, it processes node setup completion signals in a chain, but can be\r\n     * extended to handle other signal types.\r\n     *\r\n     * Note: This is a bridge between global messages and the rest of the system,\r\n     * enabling the dispatch of actions tailored to specific goals.\r\n     *\r\n     * @static\r\n     * @async\r\n     * @param {ReportingMessage} message - The message containing the signal and associated chain data.\r\n     * @returns {Promise<void>} - Resolves when the message is fully processed.\r\n     */\r\n    static async handle(message: ReportingMessage) {\r\n      const monitoring = MonitoringAgent.retrieveService();\r\n      const status = message.signal?.status;\r\n      const chainId = message.chainId;\r\n      switch (status) {\r\n        /*\r\n         * Handle ChainStatus.NODE_SETUP_COMPLETED\r\n         */\r\n        case ChainStatus.NODE_SETUP_COMPLETED: {\r\n          let count = monitoring.getChainSetupCount(chainId);\r\n          if (!count) {\r\n            monitoring.setChainSetupCount(chainId, 1);\r\n          } else {\r\n            monitoring.setChainSetupCount(chainId, count + 1);\r\n          }\r\n          count = monitoring.getChainSetupCount(chainId);\r\n          if (count && count >= message.count) {\r\n            monitoring.setChainSetupCompleted(chainId);\r\n            Logger.event(\r\n              `MonitoringSignalHandler: Chain Nodes setup completed`,\r\n            );\r\n            let chainDeployed = monitoring.getChainDeployed(chainId);\r\n            if (chainDeployed) {\r\n              await this.triggerPendingOccurrence(chainId);\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        /*\r\n         * Handle ChainStatus.CHAIN_DEPLOYED\r\n         */\r\n        case ChainStatus.CHAIN_DEPLOYED: {\r\n          monitoring.setChainDeployed(chainId);\r\n          Logger.event(`MonitoringSignalHandler: Chain deployed`);\r\n          const chainSetupCompleted =\r\n            monitoring.getChainSetupCompleted(chainId);\r\n          if (chainSetupCompleted) {\r\n            await this.triggerPendingOccurrence(chainId);\r\n          }\r\n          break;\r\n        }\r\n\r\n        case ChainStatus.CHAIN_NOTIFIED: {\r\n          const { signal, payload } = message.signal;\r\n          const supervisor = NodeSupervisor.retrieveService();\r\n          const nodeStatusMessage: NodeStatusMessage = {\r\n            payload,\r\n            chainId,\r\n            signal: signal ?? NodeSignal.NODE_ERROR,\r\n            nodeId: '',\r\n            index: 0,\r\n            count: 0,\r\n          };\r\n          supervisor.nodeStatusCallback(nodeStatusMessage);\r\n          break;\r\n        }\r\n\r\n        /*\r\n         *\r\n         */\r\n        default:\r\n          Logger.event(\r\n            `MonitoringSignalHandler:\\n\\t\\tSignal handler not found for ${JSON.stringify(message.signal)}`,\r\n          );\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Buffer } from 'buffer';\r\nimport * as http from 'http';\r\nimport * as https from 'https';\r\n\r\n/**\r\n * Sends a POST request to a specified URL with provided JSON data.\r\n *\r\n * This function handles both HTTP and HTTPS protocols, selecting the appropriate\r\n * module (`http` or `https`) based on the URL's protocol. It sends a JSON payload\r\n * and returns the server's response as a string.\r\n *\r\n * @param {URL} url - The destination URL for the POST request.\r\n * @param {string} data - JSON data to be sent in the POST request body.\r\n * @returns {Promise<string>} - A promise that resolves with the response body as a string.\r\n *\r\n * @throws {Error} Throws an error if the response status code is not in the 2xx range,\r\n * or if there is a network or request-related issue.\r\n */\r\nexport const post = async (url: URL, data: string): Promise<string> => {\r\n  const useSSL = url.protocol === 'https:';\r\n  const options = {\r\n    hostname: url.hostname,\r\n    port: url.port || (useSSL ? '443' : '80'),\r\n    path: url.pathname,\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'Content-Length': Buffer.byteLength(data),\r\n    },\r\n  };\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const req = (useSSL ? https : http).request(options, (res) => {\r\n      let data = '';\r\n      res.on('data', (chunk) => {\r\n        data += chunk;\r\n      });\r\n\r\n      res.on('end', () => {\r\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\r\n          resolve(data);\r\n        } else {\r\n          reject(\r\n            new Error(\r\n              `HTTP Error: ${res.statusCode} ${res.statusMessage} - URL: ${options.hostname}${options.path}`,\r\n            ),\r\n          );\r\n        }\r\n      });\r\n    });\r\n\r\n    req.on('error', (error) => {\r\n      reject(new Error(`Request failed to ${url.href}: ${error.message}`));\r\n    });\r\n\r\n    req.write(data);\r\n    req.end();\r\n  });\r\n};\r\n","import { ReportingMessage, BroadcastReportingMessage } from '../types/types';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { Logger } from '../utils/Logger';\r\nimport { post } from '../utils/http';\r\nimport { MonitoringAgent } from 'agents/MonitoringAgent';\r\nimport { Ext as ExtDMSH } from 'extensions/DefaultMonitoringSignalHandler';\r\n\r\nexport namespace Ext {\r\n  /**\r\n   * Type defining a callback to handle reporting signals\r\n   * @param {ReportingMessage} message - The reporting message containing signal and metadata\r\n   * @returns {Promise<void>}\r\n   */\r\n  export type ReportSignalHandlerCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    message: ReportingMessage,\r\n  ) => Promise<void>;\r\n\r\n  /**\r\n   * Type defining a callback to resolve the monitoring host for a chain\r\n   * @param {string} chainId - The ID of the chain to find the monitoring host for\r\n   * @returns {Promise<string | undefined>}\r\n   */\r\n  export type MonitoringResolverCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    chainId: string,\r\n  ) => Promise<string | undefined>;\r\n\r\n  /**\r\n   * Interface for the monitoring payload\r\n   */\r\n  export interface MCPayload {\r\n    message: ReportingMessage;\r\n    reportSignalHandler: ReportSignalHandlerCallback;\r\n  }\r\n\r\n  /**\r\n   * Interface for the broadcast reporting payload\r\n   */\r\n  export interface BRCPayload {\r\n    message: BroadcastReportingMessage;\r\n    path: string;\r\n    monitoringResolver: MonitoringResolverCallback;\r\n  }\r\n\r\n  /**\r\n   * Default callback for reporting, to be set on the initial supervisor\r\n   * @param {MCPayload} payload - Contains the message and report signal handler callback\r\n   * @returns {Promise<void>}\r\n   */\r\n  export const reportingCallback = async (\r\n    payload: MCPayload,\r\n  ): Promise<void> => {\r\n    const { message, reportSignalHandler } = payload;\r\n    await reportSignalHandler(message);\r\n  };\r\n\r\n  /**\r\n   * Interface to configure default reporting callbacks\r\n   */\r\n  export interface DefaultReportingCallbackPayload {\r\n    paths: { notify: string };\r\n    reportSignalHandler?: ReportSignalHandlerCallback;\r\n    monitoringResolver?: MonitoringResolverCallback;\r\n  }\r\n\r\n  /**\r\n   * Default handler for reporting signals\r\n   * Primarily handles the start of chains once setup is completed\r\n   * @param {ReportingMessage} message - The reporting message containing the signal and metadata\r\n   * @returns {Promise<void>}\r\n   */\r\n  const defaultReportSignalHandler = async (\r\n    message: ReportingMessage,\r\n  ): Promise<void> => {\r\n    await ExtDMSH.MonitoringSignalHandler.handle(message);\r\n  };\r\n\r\n  /**\r\n   * Default resolver to find the monitoring host for a chain\r\n   * @param {string} chainId - The ID of the chain to locate the monitoring host\r\n   * @returns {Promise<string | undefined>}\r\n   */\r\n  export const defaultMonitoringResolver = async (\r\n    chainId: string,\r\n  ): Promise<string | undefined> => {\r\n    try {\r\n      const monitoring = MonitoringAgent.retrieveService();\r\n      const monitoringHost = monitoring.getRemoteMonitoringHost(chainId);\r\n      if (monitoringHost !== undefined) {\r\n        Logger.info({\r\n          message: `DRC: Resolving host for monitoring: ${monitoringHost}`,\r\n        });\r\n        return monitoringHost;\r\n      } else\r\n        throw new Error(\r\n          'Monitoring host not found, selected chain may not exist.',\r\n        );\r\n    } catch (error) {\r\n      Logger.error({ message: (error as Error).message });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles broadcasting reporting messages to monitoring hosts\r\n   * @param {BRCPayload} payload - Contains the broadcast message, path, and monitoring resolver\r\n   * @returns {Promise<void>}\r\n   */\r\n  const broadcastReportingCallback = async (\r\n    payload: BRCPayload,\r\n  ): Promise<void> => {\r\n    try {\r\n      const { message, path, monitoringResolver } = payload;\r\n      const monitoringHost = await monitoringResolver(message.chainId);\r\n      const url = new URL(path, monitoringHost);\r\n      const data = JSON.stringify(message);\r\n      Logger.info(`BroadcastReportingCallback: Sending message to ${url}`);\r\n      await post(url, data);\r\n    } catch (error) {\r\n      Logger.error({ message: (error as Error).message });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Configures monitoring callbacks for the supervisor\r\n   * - Sets up the local reporting callback\r\n   * - Sets up the broadcast reporting callback\r\n   * @param {DefaultReportingCallbackPayload} dcPayload - Configuration for paths and handlers\r\n   * @returns {Promise<void>}\r\n   */\r\n  export const setMonitoringCallbacks = async (\r\n    dcPayload: DefaultReportingCallbackPayload,\r\n  ): Promise<void> => {\r\n    const { paths, reportSignalHandler, monitoringResolver } = dcPayload;\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n\r\n    supervisor.setMonitoringCallback(\r\n      async (message: ReportingMessage): Promise<void> => {\r\n        const payload: MCPayload = {\r\n          message,\r\n          reportSignalHandler:\r\n            reportSignalHandler ?? defaultReportSignalHandler,\r\n        };\r\n        await reportingCallback(payload);\r\n      },\r\n    );\r\n\r\n    if (reportSignalHandler) {\r\n      Logger.info('Monitoring Callback set with custom Signal Handler');\r\n    } else {\r\n      Logger.info('Monitoring Callback set with default Signal Handler');\r\n    }\r\n\r\n    supervisor.setBroadcastReportingCallback(\r\n      async (message: BroadcastReportingMessage): Promise<void> => {\r\n        const payload: BRCPayload = {\r\n          message,\r\n          path: paths.notify,\r\n          monitoringResolver: monitoringResolver ?? defaultMonitoringResolver,\r\n        };\r\n        await broadcastReportingCallback(payload);\r\n      },\r\n    );\r\n\r\n    if (monitoringResolver) {\r\n      Logger.info('Broadcast Reporting Callback set with custom Resolver');\r\n    } else {\r\n      Logger.info('Broadcast Reporting Callback set with default Resolver');\r\n    }\r\n  };\r\n}\r\n","import { Logger } from '../utils/Logger';\r\nimport {\r\n  BrodcastSetupMessage,\r\n  CallbackPayload,\r\n  ChainConfig,\r\n  PipelineMeta,\r\n} from '../types/types';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { post } from '../utils/http';\r\n\r\nexport namespace Ext {\r\n  /**\r\n   * Type defining a host resolution function to build a URL from target information\r\n   */\r\n  export type HostResolverCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    targetId: string,\r\n    // eslint-disable-next-line no-unused-vars\r\n    meta?: PipelineMeta,\r\n  ) => string | undefined;\r\n\r\n  /**\r\n   * Interface for the setup configuration broadcast payload\r\n   */\r\n  export interface BSCPayload {\r\n    message: BrodcastSetupMessage;\r\n    hostResolver: HostResolverCallback;\r\n    path: string;\r\n  }\r\n\r\n  /**\r\n   * Manages broadcasting setup configurations to different remote nodes\r\n   * @param {BSCPayload} payload - Contains the message to broadcast, host resolution function, and path\r\n   */\r\n  export const broadcastSetupCallback = async (\r\n    payload: BSCPayload,\r\n  ): Promise<void> => {\r\n    const { message, hostResolver, path } = payload;\r\n    Logger.info(`Broadcast message: ${JSON.stringify(message, null, 2)}`);\r\n    const chainConfigs: ChainConfig = message.chain.config;\r\n    const chainId: string = message.chain.id;\r\n\r\n    for (const config of chainConfigs) {\r\n      if (config.services.length === 0) {\r\n        Logger.warn('Empty services array encountered in config');\r\n        continue;\r\n      }\r\n      const service = config.services[0];\r\n      const targetId: string =\r\n        typeof service === 'string' ? service : service.targetId;\r\n      const meta = typeof service === 'string' ? undefined : service.meta;\r\n\r\n      const host = hostResolver(targetId, meta);\r\n      if (!host) {\r\n        Logger.warn(`No container address found for targetId: ${targetId}`);\r\n        continue;\r\n      }\r\n      try {\r\n        // Send a POST request to set up the node on a remote container with the specified host address\r\n        const data = JSON.stringify({\r\n          chainId,\r\n          remoteConfigs: config,\r\n        });\r\n        const url = new URL(path, host);\r\n        void post(url, data);\r\n      } catch (error) {\r\n        Logger.error(\r\n          `Unexpected error sending setup request to ${host} for targetId ${targetId}: ${(error as Error).message}`,\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Interface for the payload of remote service calls\r\n   */\r\n  export interface RSCPayload {\r\n    cbPayload: CallbackPayload;\r\n    hostResolver: HostResolverCallback;\r\n    path: string;\r\n  }\r\n\r\n  /**\r\n   * Manages sending data to remote services\r\n   * @param {RSCPayload} payload - Contains data to send, host resolution function, and path\r\n   */\r\n  export const remoteServiceCallback = async (payload: RSCPayload) => {\r\n    const { cbPayload, hostResolver, path } = payload;\r\n    Logger.info(\r\n      `Service callback payload: ${JSON.stringify(payload, null, 2)}`,\r\n    );\r\n    try {\r\n      if (!cbPayload.chainId) {\r\n        throw new Error('payload.chainId is undefined');\r\n      }\r\n\r\n      const nextConnectorUrl = hostResolver(cbPayload.targetId, cbPayload.meta);\r\n      if (!nextConnectorUrl) {\r\n        throw new Error(\r\n          `Next connector URI not found for the following target service: ${cbPayload.targetId}`,\r\n        );\r\n      }\r\n\r\n      const url = new URL(path, nextConnectorUrl);\r\n      Logger.info(`Sending data to next connector on: ${url.href}`);\r\n      const data = JSON.stringify(cbPayload);\r\n      await post(url, data);\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error sending data to next connector: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Interface for configuring default callbacks\r\n   */\r\n  export interface DefaultCallbackPayload {\r\n    paths: { setup: string; run: string };\r\n    hostResolver: HostResolverCallback;\r\n  }\r\n\r\n  /**\r\n   * Configures resolution callbacks for the node supervisor\r\n   * - Configures the setup broadcast callback\r\n   * - Configures the remote service callback\r\n   * @param {DefaultCallbackPayload} dcPayload - Configuration for paths and host resolver\r\n   */\r\n  export const setResolverCallbacks = async (\r\n    dcPayload: DefaultCallbackPayload,\r\n  ): Promise<void> => {\r\n    const { paths, hostResolver } = dcPayload;\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n\r\n    supervisor.setBroadcastSetupCallback(\r\n      async (message: BrodcastSetupMessage): Promise<void> => {\r\n        const payload: BSCPayload = {\r\n          message,\r\n          hostResolver,\r\n          path: paths.setup,\r\n        };\r\n        await broadcastSetupCallback(payload);\r\n      },\r\n    );\r\n\r\n    supervisor.setRemoteServiceCallback(\r\n      async (cbPayload: CallbackPayload): Promise<void> => {\r\n        const payload: RSCPayload = {\r\n          cbPayload,\r\n          hostResolver,\r\n          path: paths.run,\r\n        };\r\n        await remoteServiceCallback(payload);\r\n      },\r\n    );\r\n  };\r\n}\r\n","import { post } from '../utils/http';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { NodeStatusMessage } from '../types/types';\r\nimport { Logger } from 'utils/Logger';\r\nexport namespace Ext {\r\n  export type NodeStatusHandlerCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    message: any,\r\n  ) => Promise<string | undefined>;\r\n\r\n  export interface DefaultNodeStatusCallbackPayload {\r\n    paths: { enqueue: string };\r\n    hostResolver?: NodeStatusHandlerCallback;\r\n  }\r\n\r\n  export interface NSCPayload {\r\n    message: NodeStatusMessage;\r\n    hostResolver: NodeStatusHandlerCallback;\r\n    path: string;\r\n  }\r\n\r\n  export const defaultHostResolver = async (\r\n    message: any,\r\n  ): Promise<string | undefined> => {\r\n    try {\r\n      const hostURI = message.payload?.hostURI;\r\n      if (hostURI) {\r\n        return hostURI;\r\n      } else {\r\n        throw new Error('host URI not set');\r\n      }\r\n    } catch (error) {\r\n      Logger.error(`${(error as Error).message}`);\r\n    }\r\n  };\r\n\r\n  const nodeStatusCallback = async (payload: NSCPayload): Promise<void> => {\r\n    try {\r\n      const { message, path, hostResolver } = payload;\r\n      const host = await hostResolver(message);\r\n      const url = new URL(path, host);\r\n      const data = JSON.stringify(message);\r\n      Logger.info(`NodeStatusCallback: Sending message to ${url}`);\r\n      await post(url, data);\r\n    } catch (error) {\r\n      Logger.error(`${(error as Error).message}`);\r\n    }\r\n  };\r\n\r\n  export const setNodeStatusResolverCallbacks = async (\r\n    dcPayload: DefaultNodeStatusCallbackPayload,\r\n  ): Promise<void> => {\r\n    const { paths, hostResolver } = dcPayload;\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n\r\n    supervisor.setNodeStatusCallback(\r\n      async (message: NodeStatusMessage): Promise<void> => {\r\n        const payload: NSCPayload = {\r\n          message,\r\n          hostResolver: hostResolver ?? defaultHostResolver,\r\n          path: paths.enqueue,\r\n        };\r\n        await nodeStatusCallback(payload);\r\n      },\r\n    );\r\n  };\r\n}\r\n","import { NodeSupervisor } from './core/NodeSupervisor';\r\nimport { PipelineProcessor } from './core/PipelineProcessor';\r\n\r\nimport * as MonitoringModule from './extensions/DefaultMonitoringSignalHandler';\r\nimport * as ReportingModule from './extensions/DefaultReportingCallbacks';\r\nimport * as ResolverModule from './extensions/DefaultResolverCallbacks';\r\nimport * as NodeStatusModule from './extensions/DefaultNodeStatusBroadcaster';\r\n\r\nexport { NodeSupervisor };\r\nexport { PipelineProcessor };\r\n\r\nexport {\r\n  ServiceCallback,\r\n  NodeSignal,\r\n  ChainStatus,\r\n  PipelineData,\r\n  PipelineMeta,\r\n  SupervisorPayload,\r\n  CallbackPayload,\r\n  BrodcastSetupMessage,\r\n  ReportingMessage,\r\n  ChainConfig,\r\n  ChainRelation,\r\n  NodeConfig,\r\n  NodeType,\r\n  ProcessorCallback,\r\n  CombineFonction,\r\n  SupervisorPayloadSetup,\r\n  SupervisorPayloadCreate,\r\n  SupervisorPayloadDelete,\r\n  SupervisorPayloadRun,\r\n  SupervisorPayloadSendData,\r\n  SupervisorPayloadPrepareChain,\r\n  SupervisorPayloadStartChain,\r\n  SupervisorPayloadStartPendingChain,\r\n  SupervisorPayloadDeployChain,\r\n  ChainState,\r\n  DataType,\r\n  ChainType,\r\n  ProcessorPipeline,\r\n  SetupCallback,\r\n  ServiceConfig,\r\n} from './types/types';\r\n\r\nexport namespace Ext {\r\n  export type BRCPayload = ReportingModule.Ext.BRCPayload;\r\n  export type MCPayload = ReportingModule.Ext.MCPayload;\r\n  export type BSCPayload = ResolverModule.Ext.BSCPayload;\r\n  export type RSCPayload = ResolverModule.Ext.RSCPayload;\r\n  export type NSCPayload = NodeStatusModule.Ext.NSCPayload;\r\n  export const Monitoring: typeof MonitoringModule.Ext = MonitoringModule.Ext;\r\n  export const Reporting: typeof ReportingModule.Ext = ReportingModule.Ext;\r\n  export const Resolver: typeof ResolverModule.Ext = ResolverModule.Ext;\r\n  export const NodeStatus: typeof NodeStatusModule.Ext = NodeStatusModule.Ext;\r\n}\r\n"],"mappings":"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","names":["createWriteStream","mkdirSync","join","format","Colors","Logger","config","__spreadValues","level","message","now","year","month","day","hours","minutes","seconds","timestamp","formattedMessage","msg","format","DEFAULT_LOG_PATH","join","logStream","getLogFileName","initDiskLogger","mkdirSync","logFile","createWriteStream","err","defaultDiskCallback","plainMessage","DefaultCallback","payload","Logger","message","__async","NodeType","DataType","ChainType","ChainStatus","NodeSignal","setImmediate","randomUUID","EventEmitter","randomUUID","Agent","_ReportingAgentBase","Agent","agent","notification","type","status","Logger","ReportingAgentBase","ReportingAgent","ReportingAgentBase","chainId","nodeId","MonitoringAgent","_MonitoringAgent","Agent","DefaultCallback","refresh","instance","reportingCallback","broadcastReportingCallback","remoteMonitoringHost","payload","index","reporting","signal","__async","Logger","message","__spreadProps","__spreadValues","update","prev","next","_a","count","NodeStatusManager","node","__async","Logger","ChainStatus","index","generator","currentBatch","data","newSignals","signals","NodeSignal","currentSignal","error","Node","_Node","dependencies","randomUUID","ChainStatus","DataType","NodeStatusManager","config","chainId","index","count","monitoring","MonitoringAgent","Logger","statusQueue","__async","pipeline","data","result","processor","pipelines","i","notification","type","error","_a","childConfig","NodeSupervisor","NodeSignal","_b","childMode","suspendedState","isResuming","generator","processingData","nextResult","pipelineBatch","resolve","reject","setImmediate","batchPromises","pipelineData","nodeId","_c","_d","_e","supervisor","currentNode","nextNodeInfo","NodeType","ChainType","executedNodes","dep","status","id","meta","PipelineProcessor","_PipelineProcessor","config","callbackService","data","__async","Logger","randomUUID","NodeSupervisorLogger","chains","Logger","relation","chainId","nodeConfig","index","workflow","workflowId","node","key","value","NodeSupervisor","_NodeSupervisor","NodeSupervisorLogger","DefaultCallback","refresh","instance","type","workflow","MonitoringAgent","chainId","nodeStatusCallback","remoteServiceCallback","broadcastSetupCallback","broadcastReportingCallback","reportingCallback","uid","nodeId","status","__async","_a","payload","NodeSignal","Logger","notification","config","data","parentChainId","chain","children","ChainStatus","error","node","Node","initiator","processors","service","PipelineProcessor","NodeType","rootNodeId","timestamp","randomUUID","relation","monitoringHost","count","value","index","remoteMonitoringHost","chainConfig","localConfigs","remoteConfigs","__spreadProps","__spreadValues","prevNodeId","i","currentNodeId","prevNode","lastLocalNode","nextService","updatedRemoteConfigs","nextConfig","message","_b","_c","targetId","err","serviceUid","nodeConfig","Ext","MonitoringSignalHandler","chainId","__async","supervisor","NodeSupervisor","payload","NodeSignal","Logger","message","_a","monitoring","MonitoringAgent","status","ChainStatus","count","signal","nodeStatusMessage","Buffer","http","https","post","url","data","__async","useSSL","options","Buffer","resolve","reject","req","https","http","res","chunk","error","Ext","payload","__async","message","reportSignalHandler","defaultReportSignalHandler","chainId","monitoringHost","MonitoringAgent","Logger","error","broadcastReportingCallback","path","monitoringResolver","url","data","post","dcPayload","paths","supervisor","NodeSupervisor","Ext","payload","__async","message","hostResolver","path","Logger","chainConfigs","chainId","config","service","targetId","meta","host","data","url","post","error","cbPayload","nextConnectorUrl","dcPayload","paths","supervisor","NodeSupervisor","Ext","message","__async","_a","hostURI","error","Logger","nodeStatusCallback","payload","path","hostResolver","host","url","data","post","dcPayload","paths","NodeSupervisor","Ext"]}